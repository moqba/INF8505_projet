
// File generated by noodle version Q-2020.03#7e5ed72dc8#200717, Wed Mar 22 14:16:27 2023
// Copyright 2014-2020 Synopsys, Inc. All rights reserved.
// noodle -Pc -Iisg +wisg -Iruntime/include -DCHESS_CXX_ATTRIBUTES -D__tct_patch__=300 +NOrlt -D__chess__ -D__programmers_view__ dlx

#ifdef __chess__
#error "generated native file not intended for compilation by chess"
#endif

// Native equivalent of Chess promoted operations

#include "dlx_iss_types.h"
#include "dlx_chess_types.h"
#include "dlx_inline_primitives.h"
#include "dlx_chess_opns.h"

#ifndef CHESS_NATIVE_LINKAGE
#define CHESS_NATIVE_LINKAGE
#endif

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wparentheses"
#endif

#ifdef CHESS_NATIVE_NAMESPACE
namespace CHESS_NATIVE_NAMESPACE {
#endif

CHESS_NATIVE_LINKAGE bool land(bool a0, bool a1)
{
    dlx_primitive::w32 p0 = dlx_primitive::__promo_bool_on_w32(a0);
    dlx_primitive::w32 p1 = dlx_primitive::__promo_bool_on_w32(a1);
    dlx_primitive::w32 t = dlx_primitive::band(p0, p1);
    bool r; r = dlx_primitive::__promo_w32_to_bool(t);
    return r;
}

CHESS_NATIVE_LINKAGE bool lor(bool a0, bool a1)
{
    dlx_primitive::w32 p0 = dlx_primitive::__promo_bool_on_w32(a0);
    dlx_primitive::w32 p1 = dlx_primitive::__promo_bool_on_w32(a1);
    dlx_primitive::w32 t = dlx_primitive::bor(p0, p1);
    bool r; r = dlx_primitive::__promo_w32_to_bool(t);
    return r;
}

CHESS_NATIVE_LINKAGE bool lxor(bool a0, bool a1)
{
    dlx_primitive::w32 p0 = dlx_primitive::__promo_bool_on_w32(a0);
    dlx_primitive::w32 p1 = dlx_primitive::__promo_bool_on_w32(a1);
    dlx_primitive::w32 t = dlx_primitive::bxor(p0, p1);
    bool r; r = dlx_primitive::__promo_w32_to_bool(t);
    return r;
}

CHESS_NATIVE_LINKAGE bool nez(int a0)
{
    dlx_primitive::w32 p0 = a0;
    bool t = dlx_primitive::nez(p0);
    bool r; r = t;
    return r;
}

CHESS_NATIVE_LINKAGE bool eqz(int a0)
{
    dlx_primitive::w32 p0 = a0;
    bool t = dlx_primitive::eqz(p0);
    bool r; r = t;
    return r;
}

CHESS_NATIVE_LINKAGE bool nez(unsigned a0)
{
    dlx_primitive::w32 p0 = a0;
    bool t = dlx_primitive::nez(p0);
    bool r; r = t;
    return r;
}

CHESS_NATIVE_LINKAGE bool eqz(unsigned a0)
{
    dlx_primitive::w32 p0 = a0;
    bool t = dlx_primitive::eqz(p0);
    bool r; r = t;
    return r;
}

#if 0//!
CHESS_NATIVE_LINKAGE bool nez(void * a0)
{
    dlx_primitive::w32 p0 = a0;
    bool t = dlx_primitive::nez(p0);
    bool r; r = t;
    return r;
}
#endif//!

#if 0//!
CHESS_NATIVE_LINKAGE bool eqz(void * a0)
{
    dlx_primitive::w32 p0 = a0;
    bool t = dlx_primitive::eqz(p0);
    bool r; r = t;
    return r;
}
#endif//!

#if 0//!
CHESS_NATIVE_LINKAGE void udiv(unsigned a0, unsigned a1, unsigned & a2, unsigned & a3)
{
    dlx_primitive::w32 p0 = a0;
    dlx_primitive::w32 p1 = a1;
    dlx_primitive::w32 p2; //output
    dlx_primitive::w32 p3; //output
    dlx_primitive::divide(p0, p1, p2, p3);
    a2 = toVBit(p2).value();
    a3 = toVBit(p3).value();
}
#endif//!

CHESS_NATIVE_LINKAGE int clb(int a0)
{
    dlx_primitive::w32 p0 = a0;
    dlx_primitive::w32 t = dlx_primitive::clb(p0);
    int r; r = toVBit(t).value();
    return r;
}

CHESS_NATIVE_LINKAGE unsigned clb(unsigned a0)
{
    dlx_primitive::w32 p0 = a0;
    dlx_primitive::w32 t = dlx_primitive::clb(p0);
    unsigned r; r = toVBit(t).value();
    return r;
}

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint to_dint_se(int i)
    {
     return dint(i >> 31,i);
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint to_dint_ze(int i)
    {
     return dint(0,i);
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE int to_int(dint w)
    {
     return w.low;
    }
} //namespace dlx_primitive
#endif//!

namespace dlx_primitive{
CHESS_NATIVE_LINKAGE unsigned add(unsigned a0, unsigned a1, uint1 & a2)
{
    w32 p0 = a0;
    w32 p1 = a1;
    uint1 p2; //output
    w32 t = add(p0, p1, p2);
    a2 = p2;
    unsigned r; r = toVBit(t).value();
    return r;
}
} //namespace dlx_primitive

namespace dlx_primitive{
CHESS_NATIVE_LINKAGE unsigned sub(unsigned a0, unsigned a1, uint1 & a2)
{
    w32 p0 = a0;
    w32 p1 = a1;
    uint1 p2; //output
    w32 t = sub(p0, p1, p2);
    a2 = p2;
    unsigned r; r = toVBit(t).value();
    return r;
}
} //namespace dlx_primitive

namespace dlx_primitive{
CHESS_NATIVE_LINKAGE unsigned addx(unsigned a0, unsigned a1, uint1 a2, uint1 & a3)
{
    w32 p0 = a0;
    w32 p1 = a1;
    uint1 p2 = a2;
    uint1 p3; //output
    w32 t = addx(p0, p1, p2, p3);
    a3 = p3;
    unsigned r; r = toVBit(t).value();
    return r;
}
} //namespace dlx_primitive

namespace dlx_primitive{
CHESS_NATIVE_LINKAGE unsigned subx(unsigned a0, unsigned a1, uint1 a2, uint1 & a3)
{
    w32 p0 = a0;
    w32 p1 = a1;
    uint1 p2 = a2;
    uint1 p3; //output
    w32 t = subx(p0, p1, p2, p3);
    a3 = p3;
    unsigned r; r = toVBit(t).value();
    return r;
}
} //namespace dlx_primitive

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_add(dint a, dint b)
    {
     dint r;
     uint1 carry; uint1 carry2;
     if (chess_manifest(a.low == 0))
      {
       r.low = b.low;
       r.high = a.high + b.high;
      }
     else
      if (chess_manifest(b.low == 0))
       {
        r.low = a.low;
        r.high = a.high + b.high;
       }
      else
       {
        r.low = add(a.low,b.low,carry);
        r.high = addx(a.high,b.high,carry,carry2);
       }
     return r;
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_sub(dint a, dint b)
    {
     dint r;
     uint1 borrow; uint1 borrow2;
     if (chess_manifest(b.low == 0))
      {
       r.low = a.low;
       r.high = a.high - b.high;
      }
     else
      {
       r.low = sub(a.low,b.low,borrow);
       r.high = subx(a.high,b.high,borrow,borrow2);
      }
     return r;
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_and(dint a, dint b)
    {
     return dint(a.high & b.high,a.low & b.low);
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_or(dint a, dint b)
    {
     return dint(a.high | b.high,a.low | b.low);
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_xor(dint a, dint b)
    {
     return dint(a.high ^ b.high,a.low ^ b.low);
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_complement(dint a)
    {
     return dint(~a.high,~a.low);
    }
} //namespace dlx_primitive
#endif//!

namespace dlx_primitive{
CHESS_NATIVE_LINKAGE void lmuluu(unsigned a0, unsigned a1, unsigned & a2, unsigned & a3)
{
    w32 p0 = a0;
    w32 p1 = a1;
    w32 p2; //output
    w32 p3; //output
    lmuluu(p0, p1, p2, p3);
    a2 = toVBit(p2).value();
    a3 = toVBit(p3).value();
}
} //namespace dlx_primitive

namespace dlx_primitive{
CHESS_NATIVE_LINKAGE void lmulss(int a0, int a1, unsigned & a2, int & a3)
{
    w32 p0 = a0;
    w32 p1 = a1;
    w32 p2; //output
    w32 p3; //output
    lmulss(p0, p1, p2, p3);
    a2 = toVBit(p2).value();
    a3 = toVBit(p3).value();
}
} //namespace dlx_primitive

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_mul(dint a, dint b)
    {
     unsigned p1lo = 0; unsigned p1hi = 0;
     unsigned p2lo = 0; unsigned p2hi = 0;
     unsigned p3lo = 0; unsigned p3hi = 0;
     if (!chess_manifest(a.low == 0 || b.low == 0))
      lmuluu(a.low,b.low,p1lo,p1hi);
     else
      ;
     if (!chess_manifest(a.high == 0 || b.low == 0))
      lmuluu(a.high,b.low,p2lo,p2hi);
     else
      ;
     if (!chess_manifest(b.high == 0 || a.low == 0))
      lmuluu(b.high,a.low,p3lo,p3hi);
     else
      ;
     return dint(p1hi + p2lo + p3lo,p1lo);
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_lts(dint a, dint b)
    {
     if ((int)a.high < (int)b.high)
      return true;
     else
      if (a.high == b.high)
       return a.low < b.low;
      else
       return false;
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_les(dint a, dint b)
    {
     if ((int)a.high < (int)b.high)
      return true;
     else
      if (a.high == b.high)
       return a.low <= b.low;
      else
       return false;
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_ltu(dint a, dint b)
    {
     if ((unsigned)a.high < (unsigned)b.high)
      return true;
     else
      if (a.high == b.high)
       return a.low < b.low;
      else
       return false;
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_leu(dint a, dint b)
    {
     if ((unsigned)a.high < (unsigned)b.high)
      return true;
     else
      if (a.high == b.high)
       return a.low <= b.low;
      else
       return false;
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_eq(dint a, dint b)
    {
     return a.high == b.high && a.low == b.low;
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE bool l_ne(dint a, dint b)
    {
     return a.high != b.high || a.low != b.low;
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_lsl(dint a, int f)
    {
     unsigned carries;
     dint r;
     if (f == 0)
      return a;
     else
      ;
     if (f < 32)
      {
       carries = a.low >> 32 - f;
       r.low = chess_dont_warn_range(a.low << f);
       r.high = chess_dont_warn_range(a.high << f) | carries;
      }
     else
      {
       carries = a.low << f - 32;
       r.low = 0;
       r.high = carries;
      }
     return r;
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_asr(dint a, int f)
    {
     unsigned carries;
     dint r;
     if (f == 0)
      return a;
     else
      ;
     if (f < 32)
      {
       carries = a.high << 32 - f;
       r.low = chess_dont_warn_range(a.low >> f) | carries;
       r.high = chess_dont_warn_range((int)a.high >> f);
      }
     else
      {
       carries = (int)a.high >> f - 32;
       r.low = carries;
       r.high = (int)carries >> 31;
      }
     return r;
    }
} //namespace dlx_primitive
#endif//!

#if 0//!
namespace dlx_primitive{
    CHESS_NATIVE_LINKAGE dint l_lsr(dint a, int f)
    {
     unsigned carries;
     dint r;
     if (f == 0)
      return a;
     else
      ;
     if (f < 32)
      {
       carries = a.high << 32 - f;
       r.low = chess_dont_warn_range(a.low >> f) | carries;
       r.high = chess_dont_warn_range(a.high >> f);
      }
     else
      {
       carries = a.high >> f - 32;
       r.low = carries;
       r.high = 0;
      }
     return r;
    }
} //namespace dlx_primitive
#endif//!



// composed promotion conversions
#ifndef do_not_generate_composed_promo_cnvs /*trouble-shooting hook*/
namespace dlx_primitive {
    CHESS_NATIVE_LINKAGE w32 __promo_bool_on_w32(bool a)
        { return w32::BitType(a); }
    CHESS_NATIVE_LINKAGE bool __promo_w32_to_bool(w32 a)
        { return toVBit(a).value(); }
} //namespace dlx_primitive
#endif /*!do_not_generate_composed_promo_cnvs*/


#ifdef CHESS_NATIVE_NAMESPACE
} //namespace CHESS_NATIVE_NAMESPACE
#endif

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

