
// File generated by noodle version Q-2020.03#7e5ed72dc8#200717, Wed Mar 22 14:16:27 2023
// Copyright 2014-2020 Synopsys, Inc. All rights reserved.
// noodle -ps -Iisg +wisg -Iruntime/include -DCHESS_CXX_ATTRIBUTES -D__tct_patch__=300 +NOrlt -D__checkers__ dlx

#ifdef __chess__
#error "generated native file not intended for compilation by chess"
#endif

// Primitive types and functions
// used in Checkers ISS and PDG (and possibly native)

#ifndef _dlx_iss_types_h
#define _dlx_iss_types_h

#include "chess.h"
#include "vbit.h"

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wparentheses"
#endif

#ifdef CHESS_NATIVE_NAMESPACE
namespace CHESS_NATIVE_NAMESPACE {
#endif

namespace dlx_primitive {

//  Primitive types (declarations)

class w08;              // property(  8 bit   signed );
class w16;              // property( 16 bit   signed );
class w32;              // property( 32 bit   signed );
class addr;             // property( 32 bit unsigned );
class iword;            // property( 32 bit unsigned );
class uint1;            // property(  1 bit unsigned );
class uint4;            // property(  4 bit unsigned );
class uint5;            // property(  5 bit unsigned );
class uint16;           // property( 16 bit unsigned );
class int5;             // property(  5 bit   signed );
class int16;            // property( 16 bit   signed );
class int16p;           // property( 16 bit   signed );
class int26;            // property( 26 bit   signed );
class uint2;            // property(  2 bit unsigned );
class uint10;           // property( 10 bit unsigned );
class uint24;           // property( 24 bit unsigned );


//  Primitive types (definitions)

class w08
{
public:
    typedef VBit<8, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    w08() = default;
    w08(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> w08(const VBit<B, S>& a) : val(a) {}
    w08(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> w08(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    w08(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const w08& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, w08& x) { is >> x.val; return is; }
public:
};
inline const w08::BitType& toBitType(const w08& v) { return v.val; }

class w16
{
public:
    typedef VBit<16, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    w16() = default;
    w16(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> w16(const VBit<B, S>& a) : val(a) {}
    w16(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> w16(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    w16(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const w16& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, w16& x) { is >> x.val; return is; }
public:
};
inline const w16::BitType& toBitType(const w16& v) { return v.val; }

class w32
{
public:
    typedef VBit<32, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    w32() = default;
    w32(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> w32(const VBit<B, S>& a) : val(a) {}
    w32(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> w32(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    w32(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const w32& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, w32& x) { is >> x.val; return is; }
public:
    w32(int16);
    w32(uint16);
    w32(int5);
    w32(uint10);
    w32(uint24);
};
inline const w32::BitType& toBitType(const w32& v) { return v.val; }

class addr
{
public:
    typedef VBit<32, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    addr() = default;
    addr(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> addr(const VBit<B, S>& a) : val(a) {}
    addr(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> addr(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    addr(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const addr& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, addr& x) { is >> x.val; return is; }
public:
    addr(w32);
};
inline const addr::BitType& toBitType(const addr& v) { return v.val; }

class iword
{
public:
    typedef VBit<32, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    iword() = default;
    iword(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> iword(const VBit<B, S>& a) : val(a) {}
    iword(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> iword(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    iword(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const iword& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, iword& x) { is >> x.val; return is; }
public:
};
inline const iword::BitType& toBitType(const iword& v) { return v.val; }

class uint1
{
public:
    typedef VBit<1, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint1() = default;
    uint1(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> uint1(const VBit<B, S>& a) : val(a) {}
    uint1(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint1(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint1(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint1& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint1& x) { is >> x.val; return is; }
public:
};
inline const uint1::BitType& toBitType(const uint1& v) { return v.val; }

class uint4
{
public:
    typedef VBit<4, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint4() = default;
    uint4(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> uint4(const VBit<B, S>& a) : val(a) {}
    uint4(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint4(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint4(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint4& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint4& x) { is >> x.val; return is; }
public:
};
inline const uint4::BitType& toBitType(const uint4& v) { return v.val; }

class uint5
{
public:
    typedef VBit<5, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint5() = default;
    uint5(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> uint5(const VBit<B, S>& a) : val(a) {}
    uint5(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint5(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint5(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint5& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint5& x) { is >> x.val; return is; }
public:
};
inline const uint5::BitType& toBitType(const uint5& v) { return v.val; }

class uint16
{
public:
    typedef VBit<16, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint16() = default;
    uint16(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> uint16(const VBit<B, S>& a) : val(a) {}
    uint16(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint16(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint16(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint16& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint16& x) { is >> x.val; return is; }
public:
};
inline const uint16::BitType& toBitType(const uint16& v) { return v.val; }

class int5
{
public:
    typedef VBit<5, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int5() = default;
    int5(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> int5(const VBit<B, S>& a) : val(a) {}
    int5(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int5(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int5(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int5& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int5& x) { is >> x.val; return is; }
public:
};
inline const int5::BitType& toBitType(const int5& v) { return v.val; }

class int16
{
public:
    typedef VBit<16, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int16() = default;
    int16(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> int16(const VBit<B, S>& a) : val(a) {}
    int16(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int16(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int16(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int16& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int16& x) { is >> x.val; return is; }
public:
};
inline const int16::BitType& toBitType(const int16& v) { return v.val; }

class int16p
{
public:
    typedef VBit<16, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int16p() = default;
    int16p(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> int16p(const VBit<B, S>& a) : val(a) {}
    int16p(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int16p(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int16p(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int16p& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int16p& x) { is >> x.val; return is; }
public:
};
inline const int16p::BitType& toBitType(const int16p& v) { return v.val; }

class int26
{
public:
    typedef VBit<26, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int26() = default;
    int26(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> int26(const VBit<B, S>& a) : val(a) {}
    int26(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int26(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int26(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int26& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int26& x) { is >> x.val; return is; }
public:
};
inline const int26::BitType& toBitType(const int26& v) { return v.val; }

class uint2
{
public:
    typedef VBit<2, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint2() = default;
    uint2(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> uint2(const VBit<B, S>& a) : val(a) {}
    uint2(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint2(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint2(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint2& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint2& x) { is >> x.val; return is; }
public:
};
inline const uint2::BitType& toBitType(const uint2& v) { return v.val; }

class uint10
{
public:
    typedef VBit<10, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint10() = default;
    uint10(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> uint10(const VBit<B, S>& a) : val(a) {}
    uint10(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint10(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint10(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint10& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint10& x) { is >> x.val; return is; }
public:
};
inline const uint10::BitType& toBitType(const uint10& v) { return v.val; }

class uint24
{
public:
    typedef VBit<24, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint24() = default;
    uint24(VBitInitializeTag) { initialize(); }
    void initialize() { val.initialize(); }
    template <int B, bool S> uint24(const VBit<B, S>& a) : val(a) {}
    uint24(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint24(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint24(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint24& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint24& x) { is >> x.val; return is; }
public:
};
inline const uint24::BitType& toBitType(const uint24& v) { return v.val; }


//  Conversions

inline w32::w32(int16 a)                 { val = toVBit(a); }
inline w32::w32(uint16 a)                { val = toVBit(a); }
inline w32::w32(int5 a)                  { val = toVBit(a); }
inline w32::w32(uint10 a)                { val = toVBit(a); }
inline w32::w32(uint24 a)                { val = toVBit(a); }

inline addr::addr(w32 a)                 { val = toVBit(a); }

inline w32 lhi(int16p a)                { return w32::BitType((w32::BitType(toVBit(a)) << 16)); }

//  Operations

checkers_import_export /*primitive*/ w32 add(w32, w32, uint1 &);
checkers_import_export /*primitive*/ w32 add(w32, w32);
checkers_import_export /*primitive*/ w32 sub(w32, w32, uint1 &);

checkers_import_export /*primitive*/ w32 addx(w32, w32, uint1, uint1 &);
checkers_import_export /*primitive*/ w32 subx(w32, w32, uint1, uint1 &);

checkers_import_export /*primitive*/ w32 band(w32, w32);
checkers_import_export /*primitive*/ w32 bor(w32, w32);
checkers_import_export /*primitive*/ w32 bxor(w32, w32);
checkers_import_export /*primitive*/ w32 xtd(w32, w32);

checkers_import_export /*primitive*/ w32 mul(w32, w32);

checkers_import_export /*primitive*/ void lmulss(w32, w32, w32 &, w32 &);
checkers_import_export /*primitive*/ void lmulsu(w32, w32, w32 &, w32 &);
checkers_import_export /*primitive*/ void lmuluu(w32, w32, w32 &, w32 &);

checkers_import_export /*primitive*/ w32 sll(w32, w32);
checkers_import_export /*primitive*/ w32 srl(w32, w32);
checkers_import_export /*primitive*/ w32 sra(w32, w32);
checkers_import_export /*primitive*/ w32 clb(w32);

checkers_import_export /*primitive*/ w32 sge(w32, w32);
checkers_import_export /*primitive*/ w32 sgt(w32, w32);
checkers_import_export /*primitive*/ w32 sle(w32, w32);
checkers_import_export /*primitive*/ w32 slt(w32, w32);
checkers_import_export /*primitive*/ w32 sgeu(w32, w32);
checkers_import_export /*primitive*/ w32 sgtu(w32, w32);
checkers_import_export /*primitive*/ w32 sleu(w32, w32);
checkers_import_export /*primitive*/ w32 sltu(w32, w32);
checkers_import_export /*primitive*/ w32 seq(w32, w32);
checkers_import_export /*primitive*/ w32 sne(w32, w32);

checkers_import_export /*primitive*/ w32 extend_sign(w08);
checkers_import_export /*primitive*/ w32 extend_zero(w08);
checkers_import_export /*primitive*/ w32 extend_sign(w16);
checkers_import_export /*primitive*/ w32 extend_zero(w16);
checkers_import_export /*primitive*/ w08 extract_w08(w32);
checkers_import_export /*primitive*/ w16 extract_w16(w32);

checkers_import_export /*primitive*/ void divide(w32, w32, w32 &, w32 &);

checkers_import_export /*primitive*/ bool eqz(w32);
checkers_import_export /*primitive*/ bool nez(w32);
checkers_import_export /*primitive*/ w32 seq0(w32);
checkers_import_export /*primitive*/ w32 sne0(w32);

//cntrl:  checkers_import_export /*primitive*/ void br(bool, int16);
//cntrl:  checkers_import_export /*primitive*/ void j(int26);
//cntrl:  checkers_import_export /*primitive*/ void jr(w32);
checkers_import_export /*primitive*/ void nop();

//cntrl:  checkers_import_export /*primitive*/ w32 jal(int26);
//cntrl:  checkers_import_export /*primitive*/ w32 jalr(w32);

//cntrl:  checkers_import_export /*primitive*/ void hwdo(w32, int16);

checkers_import_export /*primitive*/ uint2 incr(uint2);
checkers_import_export /*primitive*/ w32 pcadd(w32, w32);

checkers_import_export /*primitive*/ w32 sign_extend_08(w32);
checkers_import_export /*primitive*/ w32 zero_extend_08(w32);
checkers_import_export /*primitive*/ w32 sign_extend_16(w32);
checkers_import_export /*primitive*/ w32 zero_extend_16(w32);


} //namespace dlx_primitive
#ifdef CHESS_NATIVE_NAMESPACE
} //namespace CHESS_NATIVE_NAMESPACE
#endif

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif


#endif /*_dlx_iss_types_h*/
