
// File generated by noodle version Q-2020.03#7e5ed72dc8#200717, Wed Mar 22 14:16:27 2023
// Copyright 2014-2020 Synopsys, Inc. All rights reserved.
// noodle -Pc -Iisg +wisg -Iruntime/include -DCHESS_CXX_ATTRIBUTES -D__tct_patch__=300 +NOrlt -D__chess__ -D__programmers_view__ dlx

#ifdef __chess__
#error "generated native file not intended for compilation by chess"
#endif

// Processor specific IO functions
// used in Checkers ISS C Variable Info (using Dwarf)
//  and in Checkers ISS hosted IO via stdio.h functions
// (As the same functions can be used for signed and unsigned application types,
//  all values are read sign-extended, and formatted later.)

#include "Mdl_[=getdesign_name=]_iss_io.h"
#include "checkers_api_l_funcs.h"
#include "checkers_api.h"
#include "checkers_hosted_clib.h"


inline void chess_report_cycle_count(Checkers_uicore* uicore, std::ostream& os) {
    long long cycle_count;
    chkapi_l_program_query_user_cyclecount(uicore, cycle_count);
    AddressType pc;
    chkapi_l_program_query_pc(uicore, pc);
    os << "(cycle=" << std::dec << cycle_count << ") (pc=" << std::dec << pc << ')';
}

//  Chess_report ancillary functions (common to ISS and native)

inline void chess_report_hex(int bits, long long val, std::ostream& os) {
    auto flags(os.flags());
    os << " 0x" << std::hex << std::setfill('0') << std::setw((bits+3)/4) << CHESS_MASKLL(val,bits);
    os.flags(flags);
}
inline void chess_report_signed  (long long  val, std::ostream& os) {
    auto flags(os.flags());
    os << ' ' << std::dec << val;
    os.flags(flags);
}
inline void chess_report_unsigned(unsigned long long val, std::ostream& os) {
    auto flags(os.flags());
    os << ' ' << std::dec << val;
    os.flags(flags);
}
inline void chess_report_expo(int prc, double val, std::ostream& os) {
    auto flags(os.flags());
    os << ' ' << std::scientific << std::setprecision(prc) << val;
    os.flags(flags);
}

#include <math.h>
#ifdef _MSC_VER
#include <float.h>
#define copysign _copysign
#endif
#ifndef CHESS_NATIVE_LINKAGE
#define CHESS_NATIVE_LINKAGE
#endif

#define dbl2expo [=getdesign_name=]_dbl2expo
#define expo2dbl [=getdesign_name=]_expo2dbl

#include <stdint.h>
extern long long dbl2expo(double, int bits, int sign, int expo, int sexp, int layo, int mbit, int zexp);
extern double expo2dbl(long long, int bits, int sign, int expo, int sexp, int layo, int mbit, int zexp);
// fast ieee versions, with NaN support, and avoiding (float)(double)(float) which isn't idempotent for some NaNs
inline int32_t flt2ieee(float   a) { return (int32_t&)a; }
inline int64_t dbl2ieee(double  a) { return (int64_t&)a; }
inline float   ieee2flt(int32_t a) { return (float  &)a; }
inline double  ieee2dbl(int64_t a) { return (double &)a; }


//TBD generate specific versions for known configurations
#define CHESS_NATIVE_ONEULL (unsigned long long)(1)
#define CHESS_NATIVE_ONES ~(unsigned long long)(0)
#define CHESS_NATIVE_FAIL(msg) return (std::cerr << "error: in dbl2expo: literal " << d << " : " << msg << '\n'), 0/*ERROR*/

CHESS_NATIVE_LINKAGE long long dbl2expo(double d, int bits, int sign,
                       int expo, int sexp, int layo, int mbit, int zexp)
{
    //assert(expo > 0);
    //assert(layo != 3); // ieee dealt with separately

    int lead = 0;                               // nr of leading bits
    if (layo > 100) { lead = layo - 100; layo = 1; }

    int exp;
#ifdef _MSC_VER
    unsigned long long sfcd = (unsigned long long)ldexp(frexp(copysign(d,1.0),&exp),64-1);
    sfcd <<= 1; //otherwise saturates as if signed
#else
    unsigned long long sfcd = (unsigned long long)ldexp(frexp(copysign(d,1.0),&exp),64);
#endif
    bool mbit_frac = mbit == 2 || mbit == 3;
    bool mbit_impl = mbit == 0 || mbit == 3;

    unsigned long long bpat = 0;    // bit pattern
    unsigned long long epat = 0;    // bit pattern of exponent (if any)

    // number of bits for significant value
    int m_bits = bits - expo - lead;
    if (sign == 2) m_bits -= 1;                 // separate sign bit
    if (sign == 1) m_bits -= 1;                 // treat as if separate
    if (mbit_impl) m_bits += 1;                 // implicit bit

    // significant value, shifted to fractional point
    int shift_factor = 64 - m_bits;
    if (shift_factor == 0) {
        bpat = sfcd;
    }
    else if (shift_factor > 0) {               // shift and round
        if (shift_factor < 64) {
            bpat = sfcd >> shift_factor;
        } else {
            bpat = 0;
        }
    }
    else
        CHESS_NATIVE_FAIL("out of range (negative shift factor)");

    if (bpat & ~(CHESS_NATIVE_ONES >> (64 - m_bits)))
        CHESS_NATIVE_FAIL("out of range");

    // sign of negative literals
    bool neg = std::signbit(d);

    // floating point formatting
    int e_max = 1 << (expo - (sexp ? 1 : 0));
    int e_min = (sexp ? -e_max + 1 : 0);
    int e_exp = exp;
    if (!mbit_frac) e_exp -= 1;                 // initial bit before .

    if (e_exp >= e_max)
        //TBD e_exp == e_max gives Inf or Nan numbers - allow ?
        CHESS_NATIVE_FAIL("exponent out of range");

    // denormalisation
    if (e_exp <= e_min) {
        int denorm_factor = e_min - e_exp;
        if (denorm_factor < m_bits) {
            e_exp = e_min; //+= denorm_factor;
            shift_factor += denorm_factor;
            bpat >>= denorm_factor;
            if (mbit_impl)  {
                shift_factor += 1;
                bpat >>= 1;
            }
        }
        else
            CHESS_NATIVE_FAIL("underflow");
    }
    if (shift_factor < 64) { // floating standard rounding to nearest even
        unsigned long long rbit = CHESS_NATIVE_ONEULL << (shift_factor-1);
        unsigned long long rpat = sfcd - (bpat << shift_factor);  // sub-fraction bits
        //assert(rpat == (sfcd & (CHESS_NATIVE_ONES >> (64 - shift_factor))));
        if (sfcd & rbit) {
            rpat &= ~rbit;                          // clear first fraction bit, i.e. zero if exact middle
            if (rpat || (bpat & CHESS_NATIVE_ONEULL)) { // round if not exact middle, or would be odd
                bpat += CHESS_NATIVE_ONEULL;
                unsigned long long sbit = CHESS_NATIVE_ONEULL << m_bits;
                if (e_exp == e_min && mbit_impl) sbit >>= 1;
                if (m_bits < 64 && (bpat & sbit)) {   // rescale
                    if (e_exp != e_min || !mbit_impl) bpat >>= 1; // else rounded up to implicit bit
                    e_exp += 1;
                }
            }
        }
    }
    if (mbit_impl)                              // discard implicit bit
        bpat &= ~(CHESS_NATIVE_ONEULL << (--m_bits));

    // exponent
    switch (sexp) {
    case 0:                                     // unsigned exponent
        if (e_exp < 0)
            CHESS_NATIVE_FAIL("unsigned exponent cannot hold negative value");
        else
            epat = (unsigned long long)e_exp;
        break;
    case 1:                                     // two's complement exponent
        if (sfcd == 0)
            e_exp = zexp;
        if (e_exp < -e_max) //?TBD
            CHESS_NATIVE_FAIL("two's complement exponent out of range");
        else
            epat = (unsigned long long)e_exp & (CHESS_NATIVE_ONES >> (64 - expo));
        break;
    case 2:                                     // sign magnitude exponent
        if (sfcd == 0) break; // (assuming 0.0 ==> 0x0)
        if (e_exp < -e_max) //?TBD
            CHESS_NATIVE_FAIL("sign magnitude exponent out of range");
        else if (e_exp < 0)
            epat = (unsigned long long)-e_exp | (CHESS_NATIVE_ONEULL << (expo-1));
        else
            epat = (unsigned long long)e_exp;
        break;
    case 3:                                     // biased exponent
        if (sfcd == 0) break;
        e_exp += e_max - 1;
        if (e_exp < 0) //?TBD
            CHESS_NATIVE_FAIL("biased exponent out of range");
        else
            epat = (unsigned long long)e_exp;
        break;
    }
    if (epat & (CHESS_NATIVE_ONES << expo))
        CHESS_NATIVE_FAIL("exponent out of range");
    
    // sign of negative literals (incl. negative zero)
    switch (sign) {
    case 0:                                     // unsigned
        if (neg)
            CHESS_NATIVE_FAIL("negative value for unsigned type");
        break;
    case 1:                                     // two's-complement
        if (expo) ++m_bits;                             // add sign bit
        if (neg) {
            bpat = 0 - bpat;
            if (expo) bpat &= CHESS_NATIVE_ONES >> (64 - m_bits);
            if (bpat                                    // allow underflow 
                && !(bpat & (CHESS_NATIVE_ONEULL << (m_bits-1))))    // sign overflow
                CHESS_NATIVE_FAIL("out of range");
        }
        else if (bpat == (CHESS_NATIVE_ONEULL << (m_bits-1)))        // saturate outer limit
            bpat -= CHESS_NATIVE_ONEULL;
        else if (bpat & (CHESS_NATIVE_ONEULL << (m_bits-1)))         // sign overflow
            CHESS_NATIVE_FAIL("out of range");
        break;
    case 2:                                     // sign magnitude
        if (neg) {
            unsigned long long sbit = CHESS_NATIVE_ONEULL << (bits-1);
            if (layo > 0) sbit >>= expo;
            // obvious for 2; also for 1 because bpat will be shifted back up
            bpat |= sbit;
        }
        //??TBD else -- check sign overflow ??
        break;
    }

    // combine exponent and significant value
    switch (layo) {
    case 0: epat <<= m_bits;    break;  // sign - exp - frac
    case 1: bpat <<= expo;      break;  // sign - frac - exp
    case 2: epat <<= m_bits + (sign == 2 ? 1 : 0);
                                break;  // exp - sign - frac
    }
    if (bpat & epat)
        CHESS_NATIVE_FAIL("unexpected overlap of exponent and significant value");
    bpat |= epat;
    if (lead) {
        bpat = bpat << (64 - bits + lead);
        bpat = (long long)bpat >> lead;
        bpat = bpat >> (64 - bits);
    }
    return bpat;
}

CHESS_NATIVE_LINKAGE double expo2dbl(long long val, int bits, int sign,
                int expo, int sexp, int layo, int mbit, int zexp)
{
    //assert(expo > 0);
    //assert(layo != 3); // ieee dealt with separately

    int lead = 0;                       // nr of leading bits
    if (layo > 100) { lead = layo - 100; layo = 1; }

    int fbts = bits - expo - 1;         // nr of significant fraction bits
    int fbtsx = fbts;                   //  (remember)
    if (sign != 2) fbts += 1;           //  (incorporate sign in fraction)

    int exb = 64 - expo;                // nr of extension bits w.r.t. expo
    int fxb = 64 - fbts;                // nr of extension bits w.r.t. fbts

    unsigned long long uval = val;
    long long eval = 0;
    bool neg = 0;

    switch (layo) {
    case 0:                     // sign - exp - fraction (default)
        //assert(sign == 2);
        neg = (val & (CHESS_NATIVE_ONEULL << (bits-1))) != 0;
        eval = (uval >> fbts) & (CHESS_NATIVE_ONES >> exb);
        uval = uval & (CHESS_NATIVE_ONES >> fxb);
        break;
    case 1:                     // sign - fraction - exp
        neg = (val & (CHESS_NATIVE_ONEULL << (bits-1))) != 0;
        eval = uval & (CHESS_NATIVE_ONES >> exb);
        uval = (uval >> expo) & (CHESS_NATIVE_ONES >> fxb);
        break;
    case 2:                     // exp - sign - fraction
        neg = (val & (CHESS_NATIVE_ONEULL << fbtsx)) != 0;
        eval = (val >> (fbtsx+1)) & (CHESS_NATIVE_ONES >> exb);      //sign extend > 64 bits
        uval = uval & (CHESS_NATIVE_ONES >> fxb);
        break;
    }
    switch (sign) {
    case 0:                     // fraction unsigned
        neg = false;                    // overrule
        break;
    case 1:                     // fraction signed (make positive)
        if (neg) uval = - ((long long)uval << fxb >> fxb);
        break;
    case 2:                     // fraction sign magnitude (default)
        break;
    }
    int e_exp = 0;
    bool denrm = false; //TBD OTHER CASES
    switch (sexp) {
    case 0:                     // exponent unsigned
        e_exp = (int)eval;
        break;
    case 1:                     // exponent signed
        e_exp = (int)(eval << exb >> exb);      // sign extend
        denrm = (!uval) //zero only     (TBD this should be an mbit option)
            && (e_exp == zexp);         //TBD use signed minimum
        break;
    case 2:                     // exponent sign magnitude
        e_exp = (int)(eval & (CHESS_NATIVE_ONES >> (exb+1)));
        if (eval & (CHESS_NATIVE_ONEULL << (expo-1))) e_exp = - e_exp;
        break;
    case 3:                     // exponent biased (default)
        e_exp = (int)(eval - ((CHESS_NATIVE_ONEULL << (expo-1)) - 1));
        denrm = !eval;          // assume denormalised if eval == 0
        break;
    }
    switch (mbit) {
    case 3:                     // implicit most-significant bit (fractional)
        e_exp -= 1;                     // bit after  .         (TO BE TESTED)
        // fall-through
    case 0:                     // implicit most-significant bit (default)
        if (!denrm) uval |= CHESS_NATIVE_ONEULL << fbts;
        else e_exp += 1;                // bit before .
        fbts += 1;                      // also one more bit
        break;
    case 1:                     // most-significant bit before .
        e_exp += 1;                     // bit before .
        break;
    case 2:                     // most-significant bit after .
        break;
    }
    double d = ldexp((double)(long long)uval,e_exp-fbts+1+lead);
    if (neg) d = copysign(d,-1.0);
    return d;
}

#undef CHESS_NATIVE_ONEULL
#undef CHESS_NATIVE_ONES
#undef CHESS_NATIVE_FAIL

//------ chess/checkers compatibility ------

#ifdef checkers_[=getdesign_name=]_PMb_si
# define chess_[=getdesign_name=]_PMb_si checkers_[=getdesign_name=]_PMb_si
#else
# define chess_[=getdesign_name=]_PMb_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_PM_si
# define chess_[=getdesign_name=]_PM_si checkers_[=getdesign_name=]_PM_si
#else
# define chess_[=getdesign_name=]_PM_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_DMb_si
# define chess_[=getdesign_name=]_DMb_si checkers_[=getdesign_name=]_DMb_si
#else
# define chess_[=getdesign_name=]_DMb_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_DMh_si
# define chess_[=getdesign_name=]_DMh_si checkers_[=getdesign_name=]_DMh_si
#else
# define chess_[=getdesign_name=]_DMh_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_DMw_si
# define chess_[=getdesign_name=]_DMw_si checkers_[=getdesign_name=]_DMw_si
#else
# define chess_[=getdesign_name=]_DMw_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_DMb_stat_si
# define chess_[=getdesign_name=]_DMb_stat_si checkers_[=getdesign_name=]_DMb_stat_si
#else
# define chess_[=getdesign_name=]_DMb_stat_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_DMh_stat_si
# define chess_[=getdesign_name=]_DMh_stat_si checkers_[=getdesign_name=]_DMh_stat_si
#else
# define chess_[=getdesign_name=]_DMh_stat_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_DMw_stat_si
# define chess_[=getdesign_name=]_DMw_stat_si checkers_[=getdesign_name=]_DMw_stat_si
#else
# define chess_[=getdesign_name=]_DMw_stat_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_R_si
# define chess_[=getdesign_name=]_R_si checkers_[=getdesign_name=]_R_si
#else
# define chess_[=getdesign_name=]_R_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_SP_si
# define chess_[=getdesign_name=]_SP_si checkers_[=getdesign_name=]_SP_si
#else
# define chess_[=getdesign_name=]_SP_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_LR_si
# define chess_[=getdesign_name=]_LR_si checkers_[=getdesign_name=]_LR_si
#else
# define chess_[=getdesign_name=]_LR_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_PL_si
# define chess_[=getdesign_name=]_PL_si checkers_[=getdesign_name=]_PL_si
#else
# define chess_[=getdesign_name=]_PL_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_PH_si
# define chess_[=getdesign_name=]_PH_si checkers_[=getdesign_name=]_PH_si
#else
# define chess_[=getdesign_name=]_PH_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_PC_si
# define chess_[=getdesign_name=]_PC_si checkers_[=getdesign_name=]_PC_si
#else
# define chess_[=getdesign_name=]_PC_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_MC_si
# define chess_[=getdesign_name=]_MC_si checkers_[=getdesign_name=]_MC_si
#else
# define chess_[=getdesign_name=]_MC_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_LF_si
# define chess_[=getdesign_name=]_LF_si checkers_[=getdesign_name=]_LF_si
#else
# define chess_[=getdesign_name=]_LF_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_LS_si
# define chess_[=getdesign_name=]_LS_si checkers_[=getdesign_name=]_LS_si
#else
# define chess_[=getdesign_name=]_LS_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_LE_si
# define chess_[=getdesign_name=]_LE_si checkers_[=getdesign_name=]_LE_si
#else
# define chess_[=getdesign_name=]_LE_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_LC_si
# define chess_[=getdesign_name=]_LC_si checkers_[=getdesign_name=]_LC_si
#else
# define chess_[=getdesign_name=]_LC_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_ZC_si
# define chess_[=getdesign_name=]_ZC_si checkers_[=getdesign_name=]_ZC_si
#else
# define chess_[=getdesign_name=]_ZC_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_ZS_si
# define chess_[=getdesign_name=]_ZS_si checkers_[=getdesign_name=]_ZS_si
#else
# define chess_[=getdesign_name=]_ZS_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_ZE_si
# define chess_[=getdesign_name=]_ZE_si checkers_[=getdesign_name=]_ZE_si
#else
# define chess_[=getdesign_name=]_ZE_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_ocd_addr_si
# define chess_[=getdesign_name=]_ocd_addr_si checkers_[=getdesign_name=]_ocd_addr_si
#else
# define chess_[=getdesign_name=]_ocd_addr_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_ocd_data_si
# define chess_[=getdesign_name=]_ocd_data_si checkers_[=getdesign_name=]_ocd_data_si
#else
# define chess_[=getdesign_name=]_ocd_data_si (-1)
#endif
#ifdef checkers_[=getdesign_name=]_ocd_instr_si
# define chess_[=getdesign_name=]_ocd_instr_si checkers_[=getdesign_name=]_ocd_instr_si
#else
# define chess_[=getdesign_name=]_ocd_instr_si (-1)
#endif

//--- direct read/write ---

int [=getdesign_name=]_read0(Checkers_uicore* uicore, long long* val, int /*n=1*/, int si, AddressType addr)
{
    Checkers_stor_addr sta(si, addr, 1, at_addr);
    Checkers_storage* sti = uicore->core()->storinfo(si);
    if (!sti)
        return uicore->errors.put(chkapi_ERR, "Illegal storage index ", "[=getdesign_name=]_read0");
    DataType vval = sti->vbit(0);
    int rt = chkapi_l_storage_get_vbit(uicore, sta, vval);
    val[0] = vval.as_signed().to_longlong();
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read value", "[=getdesign_name=]_read0");
    return chkapi_OK;
}

int [=getdesign_name=]_write0(Checkers_uicore* uicore, const long long* val, int /*n=1*/, int si, AddressType addr)
{
    /*const*/ long long* tval = (long long*)val;
    Checkers_stor_addr sta(si, addr, 1, at_addr);
    Checkers_storage* sti = uicore->core()->storinfo(si);
    if (!sti)
        return uicore->errors.put(chkapi_ERR, "Illegal storage index ", "[=getdesign_name=]_write0");
    DataType vval = sti->vbit((int)tval[0]);
    int rt = chkapi_l_storage_put_vbit(uicore, sta, vval);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write value", "[=getdesign_name=]_write0");
    return chkapi_OK;
}

int [=getdesign_name=]_read0_pad16(Checkers_uicore* uicore, long long* val, int /*n=1*/, int si, AddressType addr)
{
    Checkers_stor_addr sta(si, addr, 1, at_addr);
    Checkers_storage* sti = uicore->core()->storinfo(si);
    if (!sti)
        return uicore->errors.put(chkapi_ERR, "Illegal storage index ", "[=getdesign_name=]_read0_pad16");
    DataType vval = sti->vbit(0);
    int rt = chkapi_l_storage_get_vbit(uicore, sta, vval);
    val[0] = vval.as_signed().to_longlong();
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read value", "[=getdesign_name=]_read0_pad16");
    val[0] >>= 16; /* right padding */
    return chkapi_OK;
}

int [=getdesign_name=]_write0_pad16(Checkers_uicore* uicore, const long long* val, int /*n=1*/, int si, AddressType addr)
{
    long long tval[1];
    tval[0] = val[0] << 16; /* right padding */
    Checkers_stor_addr sta(si, addr, 1, at_addr);
    Checkers_storage* sti = uicore->core()->storinfo(si);
    if (!sti)
        return uicore->errors.put(chkapi_ERR, "Illegal storage index ", "[=getdesign_name=]_write0_pad16");
    DataType vval = sti->vbit((int)tval[0]);
    int rt = chkapi_l_storage_put_vbit(uicore, sta, vval);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write value", "[=getdesign_name=]_write0_pad16");
    return chkapi_OK;
}

//--- read/write via record aliases ---

int [=getdesign_name=]_read0_PM(Checkers_uicore* uicore, long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_read0(uicore, val, n, chess_[=getdesign_name=]_PM_si, addr);
}

int [=getdesign_name=]_write0_PM(Checkers_uicore* uicore, const long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_write0(uicore, val, n, chess_[=getdesign_name=]_PM_si, addr);
}

int [=getdesign_name=]_read0_DMw(Checkers_uicore* uicore, long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_read0(uicore, val, n, chess_[=getdesign_name=]_DMw_si, addr);
}

int [=getdesign_name=]_write0_DMw(Checkers_uicore* uicore, const long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_write0(uicore, val, n, chess_[=getdesign_name=]_DMw_si, addr);
}

int [=getdesign_name=]_read0_DMh(Checkers_uicore* uicore, long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_read0(uicore, val, n, chess_[=getdesign_name=]_DMh_si, addr);
}

int [=getdesign_name=]_write0_DMh(Checkers_uicore* uicore, const long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_write0(uicore, val, n, chess_[=getdesign_name=]_DMh_si, addr);
}

int [=getdesign_name=]_read0_pad16_DMw(Checkers_uicore* uicore, long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_read0_pad16(uicore, val, n, chess_[=getdesign_name=]_DMw_si, addr);
}

int [=getdesign_name=]_write0_pad16_DMw(Checkers_uicore* uicore, const long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_write0_pad16(uicore, val, n, chess_[=getdesign_name=]_DMw_si, addr);
}

int [=getdesign_name=]_read0_DMw_stat(Checkers_uicore* uicore, long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_read0(uicore, val, n, chess_[=getdesign_name=]_DMw_stat_si, addr);
}

int [=getdesign_name=]_write0_DMw_stat(Checkers_uicore* uicore, const long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_write0(uicore, val, n, chess_[=getdesign_name=]_DMw_stat_si, addr);
}

int [=getdesign_name=]_read0_DMh_stat(Checkers_uicore* uicore, long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_read0(uicore, val, n, chess_[=getdesign_name=]_DMh_stat_si, addr);
}

int [=getdesign_name=]_write0_DMh_stat(Checkers_uicore* uicore, const long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_write0(uicore, val, n, chess_[=getdesign_name=]_DMh_stat_si, addr);
}

int [=getdesign_name=]_read0_pad16_DMw_stat(Checkers_uicore* uicore, long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_read0_pad16(uicore, val, n, chess_[=getdesign_name=]_DMw_stat_si, addr);
}

int [=getdesign_name=]_write0_pad16_DMw_stat(Checkers_uicore* uicore, const long long* val, int n, int /*si*/, AddressType addr)
{
    return [=getdesign_name=]_write0_pad16(uicore, val, n, chess_[=getdesign_name=]_DMw_stat_si, addr);
}

//--- read/write for chess_convert or keep_in_registers representation ---

int [=getdesign_name=]_read1_record0(Checkers_uicore* uicore, long long* val, int /*n=1*/, int si, AddressType addr)
{
    val[0] = 0;
    long long fval[1] = {0};
    int rt;
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0_DMw(uicore, fval,1, si, addr + 0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of record value", "[=getdesign_name=]_read1_record0");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0_DMw(uicore, fval,1, si, addr + 4);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of record value", "[=getdesign_name=]_read1_record0");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    // complete
    return chkapi_OK;
}

int [=getdesign_name=]_write1_record0(Checkers_uicore* uicore, const long long* val, int /*n=1*/, int si, AddressType addr)
{
    /*const*/ long long* tval = (long long*)val;
    long long fval[1] = {0};
    int rt;
    // component 0 : 32 bits at 32
    fval[0] = CHESS_EXTENDLL(tval[0] >> 32, 32);
    rt = [=getdesign_name=]_write0_DMw(uicore, fval,1, si, addr + 0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write component 0 of record value", "[=getdesign_name=]_write1_record0");
    // component 1 : 32 bits at 0
    fval[0] = CHESS_EXTENDLL(tval[0] >> 0, 32);
    rt = [=getdesign_name=]_write0_DMw(uicore, fval,1, si, addr + 4);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write component 1 of record value", "[=getdesign_name=]_write1_record0");
    // complete
    return chkapi_OK;
}

int [=getdesign_name=]_read1_record1(Checkers_uicore* uicore, long long* val, int /*n=1*/, int si, AddressType addr)
{
    val[0] = 0;
    long long fval[1] = {0};
    int rt;
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0(uicore, fval,1, si, addr + 0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of record value", "[=getdesign_name=]_read1_record1");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0(uicore, fval,1, si, addr + 4);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of record value", "[=getdesign_name=]_read1_record1");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    // complete
    return chkapi_OK;
}

int [=getdesign_name=]_write1_record1(Checkers_uicore* uicore, const long long* val, int /*n=1*/, int si, AddressType addr)
{
    /*const*/ long long* tval = (long long*)val;
    long long fval[1] = {0};
    int rt;
    // component 0 : 32 bits at 32
    fval[0] = CHESS_EXTENDLL(tval[0] >> 32, 32);
    rt = [=getdesign_name=]_write0(uicore, fval,1, si, addr + 0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write component 0 of record value", "[=getdesign_name=]_write1_record1");
    // component 1 : 32 bits at 0
    fval[0] = CHESS_EXTENDLL(tval[0] >> 0, 32);
    rt = [=getdesign_name=]_write0(uicore, fval,1, si, addr + 4);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write component 1 of record value", "[=getdesign_name=]_write1_record1");
    // complete
    return chkapi_OK;
}

int [=getdesign_name=]_read1_record2(Checkers_uicore* uicore, long long* val, int /*n=1*/, int si, AddressType addr)
{
    val[0] = 0;
    long long fval[1] = {0};
    int rt;
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0_DMw_stat(uicore, fval,1, si, addr + 0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of record value", "[=getdesign_name=]_read1_record2");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0_DMw_stat(uicore, fval,1, si, addr + 4);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of record value", "[=getdesign_name=]_read1_record2");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    // complete
    return chkapi_OK;
}

int [=getdesign_name=]_write1_record2(Checkers_uicore* uicore, const long long* val, int /*n=1*/, int si, AddressType addr)
{
    /*const*/ long long* tval = (long long*)val;
    long long fval[1] = {0};
    int rt;
    // component 0 : 32 bits at 32
    fval[0] = CHESS_EXTENDLL(tval[0] >> 32, 32);
    rt = [=getdesign_name=]_write0_DMw_stat(uicore, fval,1, si, addr + 0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write component 0 of record value", "[=getdesign_name=]_write1_record2");
    // component 1 : 32 bits at 0
    fval[0] = CHESS_EXTENDLL(tval[0] >> 0, 32);
    rt = [=getdesign_name=]_write0_DMw_stat(uicore, fval,1, si, addr + 4);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write component 1 of record value", "[=getdesign_name=]_write1_record2");
    // complete
    return chkapi_OK;
}

int [=getdesign_name=]_read1_record3(Checkers_uicore* uicore, long long* val, int /*n=1*/, int si, AddressType addr)
{
    val[0] = 0;
    long long fval[1] = {0};
    int rt;
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0(uicore, fval,1, si, addr + 0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of record value", "[=getdesign_name=]_read1_record3");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0(uicore, fval,1, si, addr + 1);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of record value", "[=getdesign_name=]_read1_record3");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    // complete
    return chkapi_OK;
}

int [=getdesign_name=]_write1_record3(Checkers_uicore* uicore, const long long* val, int /*n=1*/, int si, AddressType addr)
{
    /*const*/ long long* tval = (long long*)val;
    long long fval[1] = {0};
    int rt;
    // component 0 : 32 bits at 32
    fval[0] = CHESS_EXTENDLL(tval[0] >> 32, 32);
    rt = [=getdesign_name=]_write0(uicore, fval,1, si, addr + 0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write component 0 of record value", "[=getdesign_name=]_write1_record3");
    // component 1 : 32 bits at 0
    fval[0] = CHESS_EXTENDLL(tval[0] >> 0, 32);
    rt = [=getdesign_name=]_write0(uicore, fval,1, si, addr + 1);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write component 1 of record value", "[=getdesign_name=]_write1_record3");
    // complete
    return chkapi_OK;
}

//--- read/write strings ---

int [=getdesign_name=]_readstring0(Checkers_uicore* uicore, std::string& val, int si, int csz, AddressType addr)
{
    val = "";
    while (1) {
        long long cval;
        int rt = [=getdesign_name=]_read0(uicore, &cval,1, si, addr);
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read character from string", "[=getdesign_name=]_readstring0");
        if (!cval) break;
        val += (char)(cval & 0xff);
        addr += csz;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_writestring0(Checkers_uicore* uicore, std::string val, int si, int csz, AddressType addr, int term_zero)
{
    for (unsigned i = 0; i < val.length(); i++) {
        long long cval = val[i];
        int rt = [=getdesign_name=]_write0(uicore, &cval,1, si, addr);
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write character from string", "[=getdesign_name=]_writestring0");
        addr += csz;
    }
    if (term_zero) {
        long long cval = 0;
        int rt = [=getdesign_name=]_write0(uicore, &cval,1, si, addr);
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write terminating zero from string", "[=getdesign_name=]_writestring0");
    }
    return chkapi_OK;
}

int [=getdesign_name=]_writestring0(Checkers_uicore* uicore, const char* val, int sz, int si, int csz, AddressType addr, int term_zero)
{
    for (int i = 0; i < sz; i++) {
        long long cval = val[i];
        int rt = [=getdesign_name=]_write0(uicore, &cval,1, si, addr);
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write character from string", "[=getdesign_name=]_writestring0");
        addr += csz;
    }
    if (term_zero) {
        long long cval = 0;
        int rt = [=getdesign_name=]_write0(uicore, &cval,1, si, addr);
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write terminating zero from string", "[=getdesign_name=]_writestring0");
    }
    return chkapi_OK;
}

int [=getdesign_name=]_readstring_PMb(Checkers_uicore* uicore, std::string& val, AddressType addr)
{
    return [=getdesign_name=]_readstring0(uicore, val, chess_[=getdesign_name=]_PMb_si, 1, addr);
}

int [=getdesign_name=]_writestring_PMb(Checkers_uicore* uicore, std::string val, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, chess_[=getdesign_name=]_PMb_si, 1, addr, term_zero);
}

int [=getdesign_name=]_writestring_PMb(Checkers_uicore* uicore, const char* val, int sz, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, sz,chess_[=getdesign_name=]_PMb_si, 1, addr, term_zero);
}

int [=getdesign_name=]_readstring_DMb(Checkers_uicore* uicore, std::string& val, AddressType addr)
{
    return [=getdesign_name=]_readstring0(uicore, val, chess_[=getdesign_name=]_DMb_si, 1, addr);
}

int [=getdesign_name=]_writestring_DMb(Checkers_uicore* uicore, std::string val, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, chess_[=getdesign_name=]_DMb_si, 1, addr, term_zero);
}

int [=getdesign_name=]_writestring_DMb(Checkers_uicore* uicore, const char* val, int sz, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, sz,chess_[=getdesign_name=]_DMb_si, 1, addr, term_zero);
}

int [=getdesign_name=]_readstring_DMh(Checkers_uicore* uicore, std::string& val, AddressType addr)
{
    return [=getdesign_name=]_readstring0(uicore, val, chess_[=getdesign_name=]_DMh_si, 2, addr);
}

int [=getdesign_name=]_writestring_DMh(Checkers_uicore* uicore, std::string val, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, chess_[=getdesign_name=]_DMh_si, 2, addr, term_zero);
}

int [=getdesign_name=]_writestring_DMh(Checkers_uicore* uicore, const char* val, int sz, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, sz,chess_[=getdesign_name=]_DMh_si, 2, addr, term_zero);
}

int [=getdesign_name=]_readstring_DMw(Checkers_uicore* uicore, std::string& val, AddressType addr)
{
    return [=getdesign_name=]_readstring0(uicore, val, chess_[=getdesign_name=]_DMw_si, 4, addr);
}

int [=getdesign_name=]_writestring_DMw(Checkers_uicore* uicore, std::string val, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, chess_[=getdesign_name=]_DMw_si, 4, addr, term_zero);
}

int [=getdesign_name=]_writestring_DMw(Checkers_uicore* uicore, const char* val, int sz, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, sz,chess_[=getdesign_name=]_DMw_si, 4, addr, term_zero);
}

int [=getdesign_name=]_readstring_DMb_stat(Checkers_uicore* uicore, std::string& val, AddressType addr)
{
    return [=getdesign_name=]_readstring0(uicore, val, chess_[=getdesign_name=]_DMb_stat_si, 1, addr);
}

int [=getdesign_name=]_writestring_DMb_stat(Checkers_uicore* uicore, std::string val, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, chess_[=getdesign_name=]_DMb_stat_si, 1, addr, term_zero);
}

int [=getdesign_name=]_writestring_DMb_stat(Checkers_uicore* uicore, const char* val, int sz, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, sz,chess_[=getdesign_name=]_DMb_stat_si, 1, addr, term_zero);
}

int [=getdesign_name=]_readstring_DMh_stat(Checkers_uicore* uicore, std::string& val, AddressType addr)
{
    return [=getdesign_name=]_readstring0(uicore, val, chess_[=getdesign_name=]_DMh_stat_si, 2, addr);
}

int [=getdesign_name=]_writestring_DMh_stat(Checkers_uicore* uicore, std::string val, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, chess_[=getdesign_name=]_DMh_stat_si, 2, addr, term_zero);
}

int [=getdesign_name=]_writestring_DMh_stat(Checkers_uicore* uicore, const char* val, int sz, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, sz,chess_[=getdesign_name=]_DMh_stat_si, 2, addr, term_zero);
}

int [=getdesign_name=]_readstring_DMw_stat(Checkers_uicore* uicore, std::string& val, AddressType addr)
{
    return [=getdesign_name=]_readstring0(uicore, val, chess_[=getdesign_name=]_DMw_stat_si, 4, addr);
}

int [=getdesign_name=]_writestring_DMw_stat(Checkers_uicore* uicore, std::string val, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, chess_[=getdesign_name=]_DMw_stat_si, 4, addr, term_zero);
}

int [=getdesign_name=]_writestring_DMw_stat(Checkers_uicore* uicore, const char* val, int sz, AddressType addr, int term_zero)
{
    return [=getdesign_name=]_writestring0(uicore, val, sz,chess_[=getdesign_name=]_DMw_stat_si, 4, addr, term_zero);
}


//------- Stack va_list -------

int [=getdesign_name=]_get_DMb_bool(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get bool value", "[=getdesign_name=]_get_DMb_bool");
    uval = CHESS_MASKLL(val,1);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb_bool(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb_bool");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put bool value", "[=getdesign_name=]_put_DMb_bool");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb_bool(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get bool value", "[=getdesign_name=]_getalt_DMb_bool");
    uval = CHESS_MASKLL(val,1);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb_bool(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb_bool");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put bool value", "[=getdesign_name=]_putalt_DMb_bool");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___cchar(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 1;
    int rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get char value", "[=getdesign_name=]_get_DMb___cchar");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___cchar(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___cchar");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put char value", "[=getdesign_name=]_put_DMb___cchar");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___cchar(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 1;
    int rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get char value", "[=getdesign_name=]_getalt_DMb___cchar");
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___cchar(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___cchar");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put char value", "[=getdesign_name=]_putalt_DMb___cchar");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___schar(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 1;
    int rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get signed char value", "[=getdesign_name=]_get_DMb___schar");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___schar(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___schar");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put signed char value", "[=getdesign_name=]_put_DMb___schar");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___schar(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 1;
    int rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get signed char value", "[=getdesign_name=]_getalt_DMb___schar");
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___schar(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___schar");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put signed char value", "[=getdesign_name=]_putalt_DMb___schar");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___uchar(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 1;
    int rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned char value", "[=getdesign_name=]_get_DMb___uchar");
    uval = CHESS_MASKLL(val,8);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___uchar(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___uchar");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put unsigned char value", "[=getdesign_name=]_put_DMb___uchar");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___uchar(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 1;
    int rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned char value", "[=getdesign_name=]_getalt_DMb___uchar");
    uval = CHESS_MASKLL(val,8);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___uchar(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___uchar");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put unsigned char value", "[=getdesign_name=]_putalt_DMb___uchar");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___sshort(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 2;
    addr -= addr % 2;
    int rt = [=getdesign_name=]_read0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get short value", "[=getdesign_name=]_get_DMb___sshort");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___sshort(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___sshort");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put short value", "[=getdesign_name=]_put_DMb___sshort");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___sshort(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 2;
    addr -= addr % 2;
    int rt = [=getdesign_name=]_read0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get short value", "[=getdesign_name=]_getalt_DMb___sshort");
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___sshort(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___sshort");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put short value", "[=getdesign_name=]_putalt_DMb___sshort");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___ushort(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 2;
    addr -= addr % 2;
    int rt = [=getdesign_name=]_read0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned short value", "[=getdesign_name=]_get_DMb___ushort");
    uval = CHESS_MASKLL(val,16);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___ushort(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___ushort");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put unsigned short value", "[=getdesign_name=]_put_DMb___ushort");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___ushort(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 2;
    addr -= addr % 2;
    int rt = [=getdesign_name=]_read0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned short value", "[=getdesign_name=]_getalt_DMb___ushort");
    uval = CHESS_MASKLL(val,16);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___ushort(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___ushort");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put unsigned short value", "[=getdesign_name=]_putalt_DMb___ushort");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___sint(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int value", "[=getdesign_name=]_get_DMb___sint");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___sint(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___sint");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put int value", "[=getdesign_name=]_put_DMb___sint");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___sint(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int value", "[=getdesign_name=]_getalt_DMb___sint");
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___sint(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___sint");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put int value", "[=getdesign_name=]_putalt_DMb___sint");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___uint(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned value", "[=getdesign_name=]_get_DMb___uint");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___uint(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___uint");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put unsigned value", "[=getdesign_name=]_put_DMb___uint");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___uint(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned value", "[=getdesign_name=]_getalt_DMb___uint");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___uint(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___uint");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put unsigned value", "[=getdesign_name=]_putalt_DMb___uint");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___slong(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get long value", "[=getdesign_name=]_get_DMb___slong");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___slong(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___slong");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put long value", "[=getdesign_name=]_put_DMb___slong");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___slong(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get long value", "[=getdesign_name=]_getalt_DMb___slong");
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___slong(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___slong");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put long value", "[=getdesign_name=]_putalt_DMb___slong");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___ulong(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned long value", "[=getdesign_name=]_get_DMb___ulong");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___ulong(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___ulong");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put unsigned long value", "[=getdesign_name=]_put_DMb___ulong");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___ulong(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned long value", "[=getdesign_name=]_getalt_DMb___ulong");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___ulong(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___ulong");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put unsigned long value", "[=getdesign_name=]_putalt_DMb___ulong");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___slonglong(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 8;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get long long value", "[=getdesign_name=]_get_DMb___slonglong");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___slonglong(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___slonglong");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put long long value", "[=getdesign_name=]_put_DMb___slonglong");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___slonglong(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    val = 0;
    int rt;
    long long fval = 0;
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    addr -= 4;
    addr -= addr % 4;
    rt = [=getdesign_name=]_read0_DMw(uicore, &fval,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned value", "[=getdesign_name=]_getalt_DMb___slonglong");
    val |= CHESS_MASKLL(fval, 32) << 32;
    // component 1 : 32 bits at 0
    addr -= 4;
    addr -= addr % 4;
    rt = [=getdesign_name=]_read0_DMw(uicore, &fval,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned value", "[=getdesign_name=]_getalt_DMb___slonglong");
    val |= CHESS_MASKLL(fval, 32) << 0;
    /* complete */
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___slonglong(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___slonglong");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put long long value", "[=getdesign_name=]_putalt_DMb___slonglong");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___ulonglong(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 8;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned long long value", "[=getdesign_name=]_get_DMb___ulonglong");
    uval = val;
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___ulonglong(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___ulonglong");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put unsigned long long value", "[=getdesign_name=]_put_DMb___ulonglong");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___ulonglong(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    uval = 0;
    int rt;
    long long fval = 0;
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    addr -= 4;
    addr -= addr % 4;
    rt = [=getdesign_name=]_read0_DMw(uicore, &fval,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned value", "[=getdesign_name=]_getalt_DMb___ulonglong");
    uval |= CHESS_MASKLL(fval, 32) << 32;
    // component 1 : 32 bits at 0
    addr -= 4;
    addr -= addr % 4;
    rt = [=getdesign_name=]_read0_DMw(uicore, &fval,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned value", "[=getdesign_name=]_getalt_DMb___ulonglong");
    uval |= CHESS_MASKLL(fval, 32) << 0;
    /* complete */
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___ulonglong(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___ulonglong");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put unsigned long long value", "[=getdesign_name=]_putalt_DMb___ulonglong");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___ffloat(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get float value", "[=getdesign_name=]_get_DMb___ffloat");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___ffloat(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___ffloat");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put float value", "[=getdesign_name=]_put_DMb___ffloat");
    return chkapi_OK;
}

int [=getdesign_name=]_gete_DMb___ffloat(Checkers_uicore* uicore, double& val, AddressType& addr)
{
    long long eval;
    int rt = [=getdesign_name=]_get_DMb___ffloat(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get encoded float value", "[=getdesign_name=]_gete_DMb___ffloat");
    val = checkers_expo_to_double(eval, 32, 2, 8, 3, 3, 0, 0);
    return chkapi_OK;
}

int [=getdesign_name=]_pute_DMb___ffloat(Checkers_uicore* uicore, double val, AddressType& addr)
{
    long long eval;
    int rt = checkers_floating_encoded_value(uicore, val, 32, 2, 0, 8, 3, 3, 0, 0, eval);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not encode float value", "[=getdesign_name=]_pute_DMb___ffloat");
    rt = [=getdesign_name=]_put_DMb___ffloat(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put encoded float value", "[=getdesign_name=]_pute_DMb___ffloat");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___ffloat(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    val = 0;
    int rt;
    long long fval = 0;
    addr -= 4;
    addr -= addr % 4;
    rt = [=getdesign_name=]_read0_DMw(uicore, &fval,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get float value", "[=getdesign_name=]_getalt_DMb___ffloat");
    val |= CHESS_MASKLL(fval, 32) << 0;
    val = CHESS_EXTENDLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___ffloat(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___ffloat");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put float value", "[=getdesign_name=]_putalt_DMb___ffloat");
    return chkapi_OK;
}

int [=getdesign_name=]_getealt_DMb___ffloat(Checkers_uicore* uicore, double& val, AddressType& addr)
{
    long long eval;
    int rt = [=getdesign_name=]_getalt_DMb___ffloat(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get encoded float value", "[=getdesign_name=]_getealt_DMb___ffloat");
    val = checkers_expo_to_double(eval, 32, 2, 8, 3, 3, 0, 0);
    return chkapi_OK;
}

int [=getdesign_name=]_putealt_DMb___ffloat(Checkers_uicore* uicore, double val, AddressType& addr)
{
    long long eval;
    int rt = checkers_floating_encoded_value(uicore, val, 32, 2, 0, 8, 3, 3, 0, 0, eval);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not encode float value", "[=getdesign_name=]_putealt_DMb___ffloat");
    rt = [=getdesign_name=]_putalt_DMb___ffloat(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put encoded float value", "[=getdesign_name=]_putealt_DMb___ffloat");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___fdouble(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 8;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get double value", "[=getdesign_name=]_get_DMb___fdouble");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___fdouble(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___fdouble");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put double value", "[=getdesign_name=]_put_DMb___fdouble");
    return chkapi_OK;
}

int [=getdesign_name=]_gete_DMb___fdouble(Checkers_uicore* uicore, double& val, AddressType& addr)
{
    long long eval;
    int rt = [=getdesign_name=]_get_DMb___fdouble(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get encoded double value", "[=getdesign_name=]_gete_DMb___fdouble");
    val = checkers_expo_to_double(eval, 64, 2, 11, 3, 3, 0, 0);
    return chkapi_OK;
}

int [=getdesign_name=]_pute_DMb___fdouble(Checkers_uicore* uicore, double val, AddressType& addr)
{
    long long eval;
    int rt = checkers_floating_encoded_value(uicore, val, 64, 2, 0, 11, 3, 3, 0, 0, eval);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not encode double value", "[=getdesign_name=]_pute_DMb___fdouble");
    rt = [=getdesign_name=]_put_DMb___fdouble(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put encoded double value", "[=getdesign_name=]_pute_DMb___fdouble");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___fdouble(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    val = 0;
    int rt;
    long long fval = 0;
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    addr -= 4;
    addr -= addr % 4;
    rt = [=getdesign_name=]_read0_DMw(uicore, &fval,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned value", "[=getdesign_name=]_getalt_DMb___fdouble");
    val |= CHESS_MASKLL(fval, 32) << 32;
    // component 1 : 32 bits at 0
    addr -= 4;
    addr -= addr % 4;
    rt = [=getdesign_name=]_read0_DMw(uicore, &fval,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned value", "[=getdesign_name=]_getalt_DMb___fdouble");
    val |= CHESS_MASKLL(fval, 32) << 0;
    /* complete */
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___fdouble(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___fdouble");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put double value", "[=getdesign_name=]_putalt_DMb___fdouble");
    return chkapi_OK;
}

int [=getdesign_name=]_getealt_DMb___fdouble(Checkers_uicore* uicore, double& val, AddressType& addr)
{
    long long eval;
    int rt = [=getdesign_name=]_getalt_DMb___fdouble(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get encoded double value", "[=getdesign_name=]_getealt_DMb___fdouble");
    val = checkers_expo_to_double(eval, 64, 2, 11, 3, 3, 0, 0);
    return chkapi_OK;
}

int [=getdesign_name=]_putealt_DMb___fdouble(Checkers_uicore* uicore, double val, AddressType& addr)
{
    long long eval;
    int rt = checkers_floating_encoded_value(uicore, val, 64, 2, 0, 11, 3, 3, 0, 0, eval);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not encode double value", "[=getdesign_name=]_putealt_DMb___fdouble");
    rt = [=getdesign_name=]_putalt_DMb___fdouble(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put encoded double value", "[=getdesign_name=]_putealt_DMb___fdouble");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___flongdouble(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 8;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get long double value", "[=getdesign_name=]_get_DMb___flongdouble");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___flongdouble(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___flongdouble");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put long double value", "[=getdesign_name=]_put_DMb___flongdouble");
    return chkapi_OK;
}

int [=getdesign_name=]_gete_DMb___flongdouble(Checkers_uicore* uicore, double& val, AddressType& addr)
{
    long long eval;
    int rt = [=getdesign_name=]_get_DMb___flongdouble(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get encoded long double value", "[=getdesign_name=]_gete_DMb___flongdouble");
    val = checkers_expo_to_double(eval, 64, 2, 11, 3, 3, 0, 0);
    return chkapi_OK;
}

int [=getdesign_name=]_pute_DMb___flongdouble(Checkers_uicore* uicore, double val, AddressType& addr)
{
    long long eval;
    int rt = checkers_floating_encoded_value(uicore, val, 64, 2, 0, 11, 3, 3, 0, 0, eval);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not encode long double value", "[=getdesign_name=]_pute_DMb___flongdouble");
    rt = [=getdesign_name=]_put_DMb___flongdouble(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put encoded long double value", "[=getdesign_name=]_pute_DMb___flongdouble");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___flongdouble(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    val = 0;
    int rt;
    long long fval = 0;
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    addr -= 4;
    addr -= addr % 4;
    rt = [=getdesign_name=]_read0_DMw(uicore, &fval,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned value", "[=getdesign_name=]_getalt_DMb___flongdouble");
    val |= CHESS_MASKLL(fval, 32) << 32;
    // component 1 : 32 bits at 0
    addr -= 4;
    addr -= addr % 4;
    rt = [=getdesign_name=]_read0_DMw(uicore, &fval,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get unsigned value", "[=getdesign_name=]_getalt_DMb___flongdouble");
    val |= CHESS_MASKLL(fval, 32) << 0;
    /* complete */
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___flongdouble(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___flongdouble");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write1_record0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put long double value", "[=getdesign_name=]_putalt_DMb___flongdouble");
    return chkapi_OK;
}

int [=getdesign_name=]_getealt_DMb___flongdouble(Checkers_uicore* uicore, double& val, AddressType& addr)
{
    long long eval;
    int rt = [=getdesign_name=]_getalt_DMb___flongdouble(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get encoded long double value", "[=getdesign_name=]_getealt_DMb___flongdouble");
    val = checkers_expo_to_double(eval, 64, 2, 11, 3, 3, 0, 0);
    return chkapi_OK;
}

int [=getdesign_name=]_putealt_DMb___flongdouble(Checkers_uicore* uicore, double val, AddressType& addr)
{
    long long eval;
    int rt = checkers_floating_encoded_value(uicore, val, 64, 2, 0, 11, 3, 3, 0, 0, eval);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not encode long double value", "[=getdesign_name=]_putealt_DMb___flongdouble");
    rt = [=getdesign_name=]_putalt_DMb___flongdouble(uicore, eval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put encoded long double value", "[=getdesign_name=]_putealt_DMb___flongdouble");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___Pvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void * value", "[=getdesign_name=]_get_DMb___Pvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___Pvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___Pvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void * value", "[=getdesign_name=]_put_DMb___Pvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___Pvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void * value", "[=getdesign_name=]_getalt_DMb___Pvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___Pvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___Pvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void * value", "[=getdesign_name=]_putalt_DMb___Pvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___PPMbvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(PMb) * value", "[=getdesign_name=]_get_DMb___PPMbvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___PPMbvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___PPMbvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(PMb) * value", "[=getdesign_name=]_put_DMb___PPMbvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___PPMbvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(PMb) * value", "[=getdesign_name=]_getalt_DMb___PPMbvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___PPMbvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___PPMbvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(PMb) * value", "[=getdesign_name=]_putalt_DMb___PPMbvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___PPMvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(PM) * value", "[=getdesign_name=]_get_DMb___PPMvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___PPMvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___PPMvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(PM) * value", "[=getdesign_name=]_put_DMb___PPMvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___PPMvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(PM) * value", "[=getdesign_name=]_getalt_DMb___PPMvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___PPMvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___PPMvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(PM) * value", "[=getdesign_name=]_putalt_DMb___PPMvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___PDMbvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMb) * value", "[=getdesign_name=]_get_DMb___PDMbvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___PDMbvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___PDMbvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMb) * value", "[=getdesign_name=]_put_DMb___PDMbvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___PDMbvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMb) * value", "[=getdesign_name=]_getalt_DMb___PDMbvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___PDMbvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___PDMbvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMb) * value", "[=getdesign_name=]_putalt_DMb___PDMbvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___PDMhvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMh) * value", "[=getdesign_name=]_get_DMb___PDMhvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___PDMhvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___PDMhvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMh) * value", "[=getdesign_name=]_put_DMb___PDMhvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___PDMhvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMh) * value", "[=getdesign_name=]_getalt_DMb___PDMhvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___PDMhvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___PDMhvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMh) * value", "[=getdesign_name=]_putalt_DMb___PDMhvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___PDMwvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMw) * value", "[=getdesign_name=]_get_DMb___PDMwvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___PDMwvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___PDMwvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMw) * value", "[=getdesign_name=]_put_DMb___PDMwvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___PDMwvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMw) * value", "[=getdesign_name=]_getalt_DMb___PDMwvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___PDMwvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___PDMwvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMw) * value", "[=getdesign_name=]_putalt_DMb___PDMwvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___PDMb_statvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMb_stat) * value", "[=getdesign_name=]_get_DMb___PDMb_statvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___PDMb_statvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___PDMb_statvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMb_stat) * value", "[=getdesign_name=]_put_DMb___PDMb_statvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___PDMb_statvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMb_stat) * value", "[=getdesign_name=]_getalt_DMb___PDMb_statvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___PDMb_statvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___PDMb_statvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMb_stat) * value", "[=getdesign_name=]_putalt_DMb___PDMb_statvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___PDMh_statvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMh_stat) * value", "[=getdesign_name=]_get_DMb___PDMh_statvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___PDMh_statvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___PDMh_statvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMh_stat) * value", "[=getdesign_name=]_put_DMb___PDMh_statvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___PDMh_statvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMh_stat) * value", "[=getdesign_name=]_getalt_DMb___PDMh_statvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___PDMh_statvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___PDMh_statvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMh_stat) * value", "[=getdesign_name=]_putalt_DMb___PDMh_statvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb___PDMw_statvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMw_stat) * value", "[=getdesign_name=]_get_DMb___PDMw_statvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb___PDMw_statvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb___PDMw_statvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMw_stat) * value", "[=getdesign_name=]_put_DMb___PDMw_statvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb___PDMw_statvoid(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long val = 0;
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get void chess_storage(DMw_stat) * value", "[=getdesign_name=]_getalt_DMb___PDMw_statvoid");
    uval = CHESS_MASKLL(val,32);
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb___PDMw_statvoid(Checkers_uicore* uicore, unsigned long long uval, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb___PDMw_statvoid");
    AddressType ptr(pval);
    long long val = uval;
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put void chess_storage(DMw_stat) * value", "[=getdesign_name=]_putalt_DMb___PDMw_statvoid");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb_w08(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 1;
    int rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get w08 value", "[=getdesign_name=]_get_DMb_w08");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb_w08(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb_w08");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put w08 value", "[=getdesign_name=]_put_DMb_w08");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb_w08(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 1;
    int rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get w08 value", "[=getdesign_name=]_getalt_DMb_w08");
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb_w08(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb_w08");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put w08 value", "[=getdesign_name=]_putalt_DMb_w08");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb_w16(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 2;
    addr -= addr % 2;
    int rt = [=getdesign_name=]_read0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get w16 value", "[=getdesign_name=]_get_DMb_w16");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb_w16(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb_w16");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put w16 value", "[=getdesign_name=]_put_DMb_w16");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb_w16(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 2;
    addr -= addr % 2;
    int rt = [=getdesign_name=]_read0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get w16 value", "[=getdesign_name=]_getalt_DMb_w16");
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb_w16(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb_w16");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMh(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put w16 value", "[=getdesign_name=]_putalt_DMb_w16");
    return chkapi_OK;
}

int [=getdesign_name=]_get_DMb_w32(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get w32 value", "[=getdesign_name=]_get_DMb_w32");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb_w32(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb_w32");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put w32 value", "[=getdesign_name=]_put_DMb_w32");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb_w32(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get w32 value", "[=getdesign_name=]_getalt_DMb_w32");
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb_w32(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb_w32");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put w32 value", "[=getdesign_name=]_putalt_DMb_w32");
    return chkapi_OK;
}

// ! no suitable stack memory for type `addr'

// ! no suitable stack memory for type `addr'

// ! no suitable stack memory for type `iword'

// ! no suitable stack memory for type `iword'

// ! no suitable stack memory for type `uint1'

// ! no suitable stack memory for type `uint1'

// ! no suitable stack memory for type `uint4'

// ! no suitable stack memory for type `uint4'

// ! no suitable stack memory for type `uint5'

// ! no suitable stack memory for type `uint5'

// ! no suitable stack memory for type `uint16'

// ! no suitable stack memory for type `uint16'

// ! no suitable stack memory for type `int5'

// ! no suitable stack memory for type `int5'

// ! no suitable stack memory for type `int16'

// ! no suitable stack memory for type `int16'

int [=getdesign_name=]_get_DMb_int16p(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_pad16_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int16p value", "[=getdesign_name=]_get_DMb_int16p");
    return chkapi_OK;
}

int [=getdesign_name=]_put_DMb_int16p(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_put_DMb_int16p");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_pad16_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put int16p value", "[=getdesign_name=]_put_DMb_int16p");
    return chkapi_OK;
}

int [=getdesign_name=]_getalt_DMb_int16p(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    addr -= 4;
    addr -= addr % 4;
    int rt = [=getdesign_name=]_read0_pad16_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int16p value", "[=getdesign_name=]_getalt_DMb_int16p");
    return chkapi_OK;
}

int [=getdesign_name=]_putalt_DMb_int16p(Checkers_uicore* uicore, long long val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get pointer argument", "[=getdesign_name=]_putalt_DMb_int16p");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_write0_pad16_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not put int16p value", "[=getdesign_name=]_putalt_DMb_int16p");
    return chkapi_OK;
}

// ! no suitable stack memory for type `int26'

// ! no suitable stack memory for type `int26'

// ! no suitable stack memory for type `uint2'

// ! no suitable stack memory for type `uint2'

// ! no suitable stack memory for type `uint10'

// ! no suitable stack memory for type `uint10'

// ! no suitable stack memory for type `uint24'

// ! no suitable stack memory for type `uint24'

int [=getdesign_name=]_getstring_DMb(Checkers_uicore* uicore, std::string& val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get string pointer", "[=getdesign_name=]_getstring_DMb");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_readstring_DMb(uicore, val, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read string", "[=getdesign_name=]_getstring_DMb");
    return chkapi_OK;
}

int [=getdesign_name=]_putstring_DMb(Checkers_uicore* uicore, std::string val, AddressType& addr, int term_zero)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get string pointer", "[=getdesign_name=]_putstring_DMb");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_writestring_DMb(uicore, val, ptr, term_zero);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write string", "[=getdesign_name=]_putstring_DMb");
    return chkapi_OK;
}

int [=getdesign_name=]_getstringalt_DMb(Checkers_uicore* uicore, std::string& val, AddressType& addr)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get string pointer", "[=getdesign_name=]_getstringalt_DMb");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_readstring_DMb(uicore, val, ptr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read string", "[=getdesign_name=]_getstringalt_DMb");
    return chkapi_OK;
}

int [=getdesign_name=]_putstringalt_DMb(Checkers_uicore* uicore, std::string val, AddressType& addr, int term_zero)
{
    unsigned long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___PDMbvoid(uicore, pval, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get string pointer", "[=getdesign_name=]_putstringalt_DMb");
    AddressType ptr(pval);
    rt = [=getdesign_name=]_writestring_DMb(uicore, val, ptr, term_zero);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write string", "[=getdesign_name=]_putstringalt_DMb");
    return chkapi_OK;
}

int [=getdesign_name=]_getp_DMb___sshort(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___sint(uicore,pval,addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int value", "[=getdesign_name=]_getp_DMb___sshort");
    val = CHESS_EXTENDLL(pval,16);
    return chkapi_OK;
}

int [=getdesign_name=]_getpalt_DMb___sshort(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___sint(uicore,pval,addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int value", "[=getdesign_name=]_getpalt_DMb___sshort");
    val = CHESS_EXTENDLL(pval,16);
    return chkapi_OK;
}

int [=getdesign_name=]_getp_DMb___ushort(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___sint(uicore,pval,addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int value", "[=getdesign_name=]_getp_DMb___ushort");
    uval = CHESS_MASKLL(pval,16);
    return chkapi_OK;
}

int [=getdesign_name=]_getpalt_DMb___ushort(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___sint(uicore,pval,addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int value", "[=getdesign_name=]_getpalt_DMb___ushort");
    uval = CHESS_MASKLL(pval,16);
    return chkapi_OK;
}

int [=getdesign_name=]_getp_DMb___schar(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___sint(uicore,pval,addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int value", "[=getdesign_name=]_getp_DMb___schar");
    val = CHESS_EXTENDLL(pval,8);
    return chkapi_OK;
}

int [=getdesign_name=]_getpalt_DMb___schar(Checkers_uicore* uicore, long long& val, AddressType& addr)
{
    long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___sint(uicore,pval,addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int value", "[=getdesign_name=]_getpalt_DMb___schar");
    val = CHESS_EXTENDLL(pval,8);
    return chkapi_OK;
}

int [=getdesign_name=]_getp_DMb___uchar(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long pval = 0;
    int rt = [=getdesign_name=]_get_DMb___sint(uicore,pval,addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int value", "[=getdesign_name=]_getp_DMb___uchar");
    uval = CHESS_MASKLL(pval,8);
    return chkapi_OK;
}

int [=getdesign_name=]_getpalt_DMb___uchar(Checkers_uicore* uicore, unsigned long long& uval, AddressType& addr)
{
    long long pval = 0;
    int rt = [=getdesign_name=]_getalt_DMb___sint(uicore,pval,addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not get int value", "[=getdesign_name=]_getpalt_DMb___uchar");
    uval = CHESS_MASKLL(pval,8);
    return chkapi_OK;
}


//------- Access to C Types: built-in, primitive and application -------

struct Ctp_access_fn {
    int strg_idx;
    const char* type_nm;
    checkers_read_signed_ptr read_fn;
    checkers_write_signed_ptr write_fn;
};

static Ctp_access_fn acfns[] = {
#ifdef checkers_[=getdesign_name=]_PMb_si
    { checkers_[=getdesign_name=]_PMb_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PMb_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PMb_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PMb_si, "w08", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PMb_si, "iword", [=getdesign_name=]_read0_PM, [=getdesign_name=]_write0_PM },
#endif //checkers_[=getdesign_name=]_PMb_si
#ifdef checkers_[=getdesign_name=]_PM_si
    { checkers_[=getdesign_name=]_PM_si, "iword", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_PM_si
#ifdef checkers_[=getdesign_name=]_DMb_si
    { checkers_[=getdesign_name=]_DMb_si, "bool", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMb_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMb_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMb_si, "__sshort", [=getdesign_name=]_read0_DMh, [=getdesign_name=]_write0_DMh },
    { checkers_[=getdesign_name=]_DMb_si, "__ushort", [=getdesign_name=]_read0_DMh, [=getdesign_name=]_write0_DMh },
    { checkers_[=getdesign_name=]_DMb_si, "__sint", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__uint", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__slong", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__ulong", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__slonglong", [=getdesign_name=]_read1_record0, [=getdesign_name=]_write1_record0 },
    { checkers_[=getdesign_name=]_DMb_si, "__ulonglong", [=getdesign_name=]_read1_record0, [=getdesign_name=]_write1_record0 },
    { checkers_[=getdesign_name=]_DMb_si, "__ffloat", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__fdouble", [=getdesign_name=]_read1_record0, [=getdesign_name=]_write1_record0 },
    { checkers_[=getdesign_name=]_DMb_si, "__flongdouble", [=getdesign_name=]_read1_record0, [=getdesign_name=]_write1_record0 },
    { checkers_[=getdesign_name=]_DMb_si, "__Pvoid", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__PPMbvoid", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__PPMvoid", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__PDMbvoid", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__PDMhvoid", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__PDMwvoid", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__PDMb_statvoid", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__PDMh_statvoid", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "__PDMw_statvoid", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "w08", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMb_si, "w16", [=getdesign_name=]_read0_DMh, [=getdesign_name=]_write0_DMh },
    { checkers_[=getdesign_name=]_DMb_si, "w32", [=getdesign_name=]_read0_DMw, [=getdesign_name=]_write0_DMw },
    { checkers_[=getdesign_name=]_DMb_si, "int16p", [=getdesign_name=]_read0_pad16_DMw, [=getdesign_name=]_write0_pad16_DMw },
#endif //checkers_[=getdesign_name=]_DMb_si
#ifdef checkers_[=getdesign_name=]_DMh_si
    { checkers_[=getdesign_name=]_DMh_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMh_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMh_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMh_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMh_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMh_si, "w16", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_DMh_si
#ifdef checkers_[=getdesign_name=]_DMw_si
    { checkers_[=getdesign_name=]_DMw_si, "bool", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__sint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__uint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__slong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__ulong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__slonglong", [=getdesign_name=]_read1_record1, [=getdesign_name=]_write1_record1 },
    { checkers_[=getdesign_name=]_DMw_si, "__ulonglong", [=getdesign_name=]_read1_record1, [=getdesign_name=]_write1_record1 },
    { checkers_[=getdesign_name=]_DMw_si, "__ffloat", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__fdouble", [=getdesign_name=]_read1_record1, [=getdesign_name=]_write1_record1 },
    { checkers_[=getdesign_name=]_DMw_si, "__flongdouble", [=getdesign_name=]_read1_record1, [=getdesign_name=]_write1_record1 },
    { checkers_[=getdesign_name=]_DMw_si, "__Pvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__PPMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__PPMvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__PDMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__PDMhvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__PDMwvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__PDMb_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__PDMh_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "__PDMw_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "w32", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_si, "int16p", [=getdesign_name=]_read0_pad16, [=getdesign_name=]_write0_pad16 },
#endif //checkers_[=getdesign_name=]_DMw_si
#ifdef checkers_[=getdesign_name=]_DMb_stat_si
    { checkers_[=getdesign_name=]_DMb_stat_si, "bool", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__sshort", [=getdesign_name=]_read0_DMh_stat, [=getdesign_name=]_write0_DMh_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__ushort", [=getdesign_name=]_read0_DMh_stat, [=getdesign_name=]_write0_DMh_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__sint", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__uint", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__slong", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__ulong", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__slonglong", [=getdesign_name=]_read1_record2, [=getdesign_name=]_write1_record2 },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__ulonglong", [=getdesign_name=]_read1_record2, [=getdesign_name=]_write1_record2 },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__ffloat", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__fdouble", [=getdesign_name=]_read1_record2, [=getdesign_name=]_write1_record2 },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__flongdouble", [=getdesign_name=]_read1_record2, [=getdesign_name=]_write1_record2 },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__Pvoid", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__PPMbvoid", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__PPMvoid", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__PDMbvoid", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__PDMhvoid", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__PDMwvoid", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__PDMb_statvoid", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__PDMh_statvoid", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "__PDMw_statvoid", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "w08", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMb_stat_si, "w16", [=getdesign_name=]_read0_DMh_stat, [=getdesign_name=]_write0_DMh_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "w32", [=getdesign_name=]_read0_DMw_stat, [=getdesign_name=]_write0_DMw_stat },
    { checkers_[=getdesign_name=]_DMb_stat_si, "int16p", [=getdesign_name=]_read0_pad16_DMw_stat, [=getdesign_name=]_write0_pad16_DMw_stat },
#endif //checkers_[=getdesign_name=]_DMb_stat_si
#ifdef checkers_[=getdesign_name=]_DMh_stat_si
    { checkers_[=getdesign_name=]_DMh_stat_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMh_stat_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMh_stat_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMh_stat_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMh_stat_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMh_stat_si, "w16", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_DMh_stat_si
#ifdef checkers_[=getdesign_name=]_DMw_stat_si
    { checkers_[=getdesign_name=]_DMw_stat_si, "bool", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__sint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__uint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__slong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__ulong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__slonglong", [=getdesign_name=]_read1_record1, [=getdesign_name=]_write1_record1 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__ulonglong", [=getdesign_name=]_read1_record1, [=getdesign_name=]_write1_record1 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__ffloat", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__fdouble", [=getdesign_name=]_read1_record1, [=getdesign_name=]_write1_record1 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__flongdouble", [=getdesign_name=]_read1_record1, [=getdesign_name=]_write1_record1 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__Pvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__PPMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__PPMvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__PDMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__PDMhvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__PDMwvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__PDMb_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__PDMh_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "__PDMw_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "w32", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_DMw_stat_si, "int16p", [=getdesign_name=]_read0_pad16, [=getdesign_name=]_write0_pad16 },
#endif //checkers_[=getdesign_name=]_DMw_stat_si
#ifdef checkers_[=getdesign_name=]_R_si
    { checkers_[=getdesign_name=]_R_si, "bool", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__sint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__uint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__slong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__ulong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__slonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_R_si, "__ulonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_R_si, "__ffloat", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__fdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_R_si, "__flongdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_R_si, "__Pvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__PPMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__PPMvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__PDMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__PDMhvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__PDMwvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__PDMb_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__PDMh_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "__PDMw_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "w32", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_R_si, "int16p", [=getdesign_name=]_read0_pad16, [=getdesign_name=]_write0_pad16 },
#endif //checkers_[=getdesign_name=]_R_si
#ifdef checkers_[=getdesign_name=]_SP_si
    { checkers_[=getdesign_name=]_SP_si, "bool", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__sint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__uint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__slong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__ulong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__slonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_SP_si, "__ulonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_SP_si, "__ffloat", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__fdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_SP_si, "__flongdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_SP_si, "__Pvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__PPMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__PPMvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__PDMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__PDMhvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__PDMwvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__PDMb_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__PDMh_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "__PDMw_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "w32", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_SP_si, "int16p", [=getdesign_name=]_read0_pad16, [=getdesign_name=]_write0_pad16 },
#endif //checkers_[=getdesign_name=]_SP_si
#ifdef checkers_[=getdesign_name=]_LR_si
    { checkers_[=getdesign_name=]_LR_si, "bool", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__sint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__uint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__slong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__ulong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__slonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_LR_si, "__ulonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_LR_si, "__ffloat", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__fdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_LR_si, "__flongdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_LR_si, "__Pvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__PPMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__PPMvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__PDMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__PDMhvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__PDMwvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__PDMb_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__PDMh_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "__PDMw_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "w32", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LR_si, "int16p", [=getdesign_name=]_read0_pad16, [=getdesign_name=]_write0_pad16 },
#endif //checkers_[=getdesign_name=]_LR_si
#ifdef checkers_[=getdesign_name=]_PL_si
    { checkers_[=getdesign_name=]_PL_si, "bool", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__sint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__uint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__slong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__ulong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__slonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PL_si, "__ulonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PL_si, "__ffloat", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__fdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PL_si, "__flongdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PL_si, "__Pvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__PPMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__PPMvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__PDMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__PDMhvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__PDMwvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__PDMb_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__PDMh_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "__PDMw_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "w32", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PL_si, "int16p", [=getdesign_name=]_read0_pad16, [=getdesign_name=]_write0_pad16 },
#endif //checkers_[=getdesign_name=]_PL_si
#ifdef checkers_[=getdesign_name=]_PH_si
    { checkers_[=getdesign_name=]_PH_si, "bool", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__sint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__uint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__slong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__ulong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__slonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PH_si, "__ulonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PH_si, "__ffloat", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__fdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PH_si, "__flongdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PH_si, "__Pvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__PPMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__PPMvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__PDMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__PDMhvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__PDMwvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__PDMb_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__PDMh_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "__PDMw_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "w32", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PH_si, "int16p", [=getdesign_name=]_read0_pad16, [=getdesign_name=]_write0_pad16 },
#endif //checkers_[=getdesign_name=]_PH_si
#ifdef checkers_[=getdesign_name=]_PC_si
    { checkers_[=getdesign_name=]_PC_si, "bool", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__sint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__uint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__slong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__ulong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__slonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PC_si, "__ulonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PC_si, "__ffloat", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__fdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PC_si, "__flongdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_PC_si, "__Pvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__PPMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__PPMvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__PDMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__PDMhvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__PDMwvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__PDMb_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__PDMh_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "__PDMw_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "w32", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_PC_si, "int16p", [=getdesign_name=]_read0_pad16, [=getdesign_name=]_write0_pad16 },
#endif //checkers_[=getdesign_name=]_PC_si
#ifdef checkers_[=getdesign_name=]_MC_si
    { checkers_[=getdesign_name=]_MC_si, "uint1", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_MC_si
#ifdef checkers_[=getdesign_name=]_LF_si
    { checkers_[=getdesign_name=]_LF_si, "uint2", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_LF_si
#ifdef checkers_[=getdesign_name=]_LS_si
    { checkers_[=getdesign_name=]_LS_si, "addr", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_LS_si
#ifdef checkers_[=getdesign_name=]_LE_si
    { checkers_[=getdesign_name=]_LE_si, "addr", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_LE_si
#ifdef checkers_[=getdesign_name=]_LC_si
    { checkers_[=getdesign_name=]_LC_si, "bool", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__sint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__uint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__slong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__ulong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__slonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_LC_si, "__ulonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_LC_si, "__ffloat", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__fdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_LC_si, "__flongdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_LC_si, "__Pvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__PPMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__PPMvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__PDMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__PDMhvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__PDMwvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__PDMb_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__PDMh_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "__PDMw_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "w32", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_LC_si, "int16p", [=getdesign_name=]_read0_pad16, [=getdesign_name=]_write0_pad16 },
#endif //checkers_[=getdesign_name=]_LC_si
#ifdef checkers_[=getdesign_name=]_ZC_si
    { checkers_[=getdesign_name=]_ZC_si, "bool", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__sshort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__ushort", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__sint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__uint", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__slong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__ulong", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__slonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_ZC_si, "__ulonglong", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_ZC_si, "__ffloat", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__fdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_ZC_si, "__flongdouble", [=getdesign_name=]_read1_record3, [=getdesign_name=]_write1_record3 },
    { checkers_[=getdesign_name=]_ZC_si, "__Pvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__PPMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__PPMvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__PDMbvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__PDMhvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__PDMwvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__PDMb_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__PDMh_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "__PDMw_statvoid", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "w32", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ZC_si, "int16p", [=getdesign_name=]_read0_pad16, [=getdesign_name=]_write0_pad16 },
#endif //checkers_[=getdesign_name=]_ZC_si
#ifdef checkers_[=getdesign_name=]_ZS_si
    { checkers_[=getdesign_name=]_ZS_si, "addr", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_ZS_si
#ifdef checkers_[=getdesign_name=]_ZE_si
    { checkers_[=getdesign_name=]_ZE_si, "addr", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_ZE_si
#ifdef checkers_[=getdesign_name=]_ocd_addr_si
    { checkers_[=getdesign_name=]_ocd_addr_si, "addr", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_ocd_addr_si
#ifdef checkers_[=getdesign_name=]_ocd_data_si
    { checkers_[=getdesign_name=]_ocd_data_si, "__cchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ocd_data_si, "__schar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ocd_data_si, "__uchar", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
    { checkers_[=getdesign_name=]_ocd_data_si, "w08", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_ocd_data_si
#ifdef checkers_[=getdesign_name=]_ocd_instr_si
    { checkers_[=getdesign_name=]_ocd_instr_si, "iword", [=getdesign_name=]_read0, [=getdesign_name=]_write0 },
#endif //checkers_[=getdesign_name=]_ocd_instr_si
    { -1, 0, 0, 0 } /* sentinel */
};


//------- Type-specific chess_assert functions -------

int [=getdesign_name=]_chess_assert_bool(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert_bool");
    val[0] |= CHESS_MASKLL(fval[0], 1) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___cchar(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___cchar");
    val[0] |= CHESS_MASKLL(fval[0], 8) << 0;
    val[0] = CHESS_EXTENDLL(val[0],8);
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___schar(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___schar");
    val[0] |= CHESS_MASKLL(fval[0], 8) << 0;
    val[0] = CHESS_EXTENDLL(val[0],8);
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___uchar(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___uchar");
    val[0] |= CHESS_MASKLL(fval[0], 8) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___sshort(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___sshort");
    val[0] |= CHESS_MASKLL(fval[0], 16) << 0;
    val[0] = CHESS_EXTENDLL(val[0],16);
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___ushort(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___ushort");
    val[0] |= CHESS_MASKLL(fval[0], 16) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___sint(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___sint");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    val[0] = CHESS_EXTENDLL(val[0],32);
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___uint(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___uint");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___slong(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___slong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    val[0] = CHESS_EXTENDLL(val[0],32);
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___ulong(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___ulong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___slonglong(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_assert record value", "[=getdesign_name=]_chess_assert___slonglong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(5));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_assert record value", "[=getdesign_name=]_chess_assert___slonglong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    /* complete */
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___ulonglong(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_assert record value", "[=getdesign_name=]_chess_assert___ulonglong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(5));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_assert record value", "[=getdesign_name=]_chess_assert___ulonglong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    /* complete */
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___ffloat(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___ffloat");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    val[0] = CHESS_EXTENDLL(val[0],32);
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___fdouble(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_assert record value", "[=getdesign_name=]_chess_assert___fdouble");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(5));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_assert record value", "[=getdesign_name=]_chess_assert___fdouble");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    /* complete */
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___flongdouble(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_assert record value", "[=getdesign_name=]_chess_assert___flongdouble");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(5));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_assert record value", "[=getdesign_name=]_chess_assert___flongdouble");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    /* complete */
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___Pvoid(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___Pvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___PPMbvoid(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___PPMbvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___PPMvoid(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___PPMvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___PDMbvoid(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___PDMbvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___PDMhvoid(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___PDMhvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___PDMwvoid(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___PDMwvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___PDMb_statvoid(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___PDMb_statvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___PDMh_statvoid(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___PDMh_statvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert___PDMw_statvoid(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert___PDMw_statvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert_w32(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert_w32");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    val[0] = CHESS_EXTENDLL(val[0],32);
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_assert_int16p(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0_pad16(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_assert value", "[=getdesign_name=]_chess_assert_int16p");
    val[0] |= CHESS_MASKLL(fval[0], 16) << 0;
    val[0] = CHESS_EXTENDLL(val[0],16);
    oval = val[0] != 0 ? 1 : 0;
    return chkapi_OK;
}

struct Chess_assert_fn {
    const char* type_nm;
    checkers_chess_assert_ptr assert_fn;
};

static Chess_assert_fn cafns[] = {
    { "bool", [=getdesign_name=]_chess_assert_bool },
    { "__cchar", [=getdesign_name=]_chess_assert___cchar },
    { "__schar", [=getdesign_name=]_chess_assert___schar },
    { "__uchar", [=getdesign_name=]_chess_assert___uchar },
    { "__sshort", [=getdesign_name=]_chess_assert___sshort },
    { "__ushort", [=getdesign_name=]_chess_assert___ushort },
    { "__sint", [=getdesign_name=]_chess_assert___sint },
    { "__uint", [=getdesign_name=]_chess_assert___uint },
    { "__slong", [=getdesign_name=]_chess_assert___slong },
    { "__ulong", [=getdesign_name=]_chess_assert___ulong },
    { "__slonglong", [=getdesign_name=]_chess_assert___slonglong },
    { "__ulonglong", [=getdesign_name=]_chess_assert___ulonglong },
    { "__ffloat", [=getdesign_name=]_chess_assert___ffloat },
    { "__fdouble", [=getdesign_name=]_chess_assert___fdouble },
    { "__flongdouble", [=getdesign_name=]_chess_assert___flongdouble },
    { "__Pvoid", [=getdesign_name=]_chess_assert___Pvoid },
    { "__PPMbvoid", [=getdesign_name=]_chess_assert___PPMbvoid },
    { "__PPMvoid", [=getdesign_name=]_chess_assert___PPMvoid },
    { "__PDMbvoid", [=getdesign_name=]_chess_assert___PDMbvoid },
    { "__PDMhvoid", [=getdesign_name=]_chess_assert___PDMhvoid },
    { "__PDMwvoid", [=getdesign_name=]_chess_assert___PDMwvoid },
    { "__PDMb_statvoid", [=getdesign_name=]_chess_assert___PDMb_statvoid },
    { "__PDMh_statvoid", [=getdesign_name=]_chess_assert___PDMh_statvoid },
    { "__PDMw_statvoid", [=getdesign_name=]_chess_assert___PDMw_statvoid },
    { "w32", [=getdesign_name=]_chess_assert_w32 },
    { "int16p", [=getdesign_name=]_chess_assert_int16p },
    { 0, 0 } /* sentinel */
};


//------- Type-specific chess_report functions -------

int [=getdesign_name=]_chess_report_bool(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report_bool");
    val[0] |= CHESS_MASKLL(fval[0], 1) << 0;
    os << "chess_report(bool):";
    chess_report_hex(1, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___cchar(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___cchar");
    val[0] |= CHESS_MASKLL(fval[0], 8) << 0;
    val[0] = CHESS_EXTENDLL(val[0],8);
    os << "chess_report(char):";
    chess_report_hex(8, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_signed(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___schar(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___schar");
    val[0] |= CHESS_MASKLL(fval[0], 8) << 0;
    val[0] = CHESS_EXTENDLL(val[0],8);
    os << "chess_report(signed char):";
    chess_report_hex(8, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_signed(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___uchar(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___uchar");
    val[0] |= CHESS_MASKLL(fval[0], 8) << 0;
    os << "chess_report(unsigned char):";
    chess_report_hex(8, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___sshort(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___sshort");
    val[0] |= CHESS_MASKLL(fval[0], 16) << 0;
    val[0] = CHESS_EXTENDLL(val[0],16);
    os << "chess_report(short):";
    chess_report_hex(16, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_signed(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___ushort(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___ushort");
    val[0] |= CHESS_MASKLL(fval[0], 16) << 0;
    os << "chess_report(unsigned short):";
    chess_report_hex(16, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___sint(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___sint");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    val[0] = CHESS_EXTENDLL(val[0],32);
    os << "chess_report(int):";
    chess_report_hex(32, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_signed(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___uint(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___uint");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    os << "chess_report(unsigned):";
    chess_report_hex(32, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___slong(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___slong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    val[0] = CHESS_EXTENDLL(val[0],32);
    os << "chess_report(long):";
    chess_report_hex(32, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_signed(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___ulong(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___ulong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    os << "chess_report(unsigned long):";
    chess_report_hex(32, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___slonglong(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_report record value", "[=getdesign_name=]_chess_report___slonglong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(5));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_report record value", "[=getdesign_name=]_chess_report___slonglong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    /* complete */
    os << "chess_report(long long):";
    chess_report_hex(64, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_signed(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___ulonglong(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_report record value", "[=getdesign_name=]_chess_report___ulonglong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(5));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_report record value", "[=getdesign_name=]_chess_report___ulonglong");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    /* complete */
    os << "chess_report(unsigned long long):";
    chess_report_hex(64, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___ffloat(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___ffloat");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    val[0] = CHESS_EXTENDLL(val[0],32);
    os << "chess_report(float):";
    chess_report_hex(32, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_expo(7, ieee2flt(val[0]), os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___fdouble(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_report record value", "[=getdesign_name=]_chess_report___fdouble");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(5));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_report record value", "[=getdesign_name=]_chess_report___fdouble");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    /* complete */
    os << "chess_report(double):";
    chess_report_hex(64, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_expo(16, ieee2dbl(val[0]), os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___flongdouble(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_report record value", "[=getdesign_name=]_chess_report___flongdouble");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 32;
    // component 1 : 32 bits at 0
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(5));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_report record value", "[=getdesign_name=]_chess_report___flongdouble");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    /* complete */
    os << "chess_report(long double):";
    chess_report_hex(64, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_expo(16, ieee2dbl(val[0]), os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___Pvoid(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___Pvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    os << "chess_report(void*):";
    chess_report_hex(32, (unsigned long long)val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned((unsigned long long)val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___PPMbvoid(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___PPMbvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    os << "chess_report(void*):";
    chess_report_hex(32, (unsigned long long)val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned((unsigned long long)val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___PPMvoid(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___PPMvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    os << "chess_report(void*):";
    chess_report_hex(32, (unsigned long long)val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned((unsigned long long)val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___PDMbvoid(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___PDMbvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    os << "chess_report(void*):";
    chess_report_hex(32, (unsigned long long)val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned((unsigned long long)val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___PDMhvoid(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___PDMhvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    os << "chess_report(void*):";
    chess_report_hex(32, (unsigned long long)val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned((unsigned long long)val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___PDMwvoid(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___PDMwvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    os << "chess_report(void*):";
    chess_report_hex(32, (unsigned long long)val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned((unsigned long long)val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___PDMb_statvoid(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___PDMb_statvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    os << "chess_report(void*):";
    chess_report_hex(32, (unsigned long long)val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned((unsigned long long)val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___PDMh_statvoid(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___PDMh_statvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    os << "chess_report(void*):";
    chess_report_hex(32, (unsigned long long)val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned((unsigned long long)val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report___PDMw_statvoid(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report___PDMw_statvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    os << "chess_report(void*):";
    chess_report_hex(32, (unsigned long long)val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_unsigned((unsigned long long)val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report_w32(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report_w32");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    val[0] = CHESS_EXTENDLL(val[0],32);
    os << "chess_report(dlx_primitive::w32):";
    chess_report_hex(32, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_signed(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_report_int16p(Checkers_uicore* uicore, std::ostream& os)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0_pad16(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_report value", "[=getdesign_name=]_chess_report_int16p");
    val[0] |= CHESS_MASKLL(fval[0], 16) << 0;
    val[0] = CHESS_EXTENDLL(val[0],16);
    os << "chess_report(dlx_primitive::int16p):";
    chess_report_hex(16, val[0], os);
    os << " //";
    chess_report_cycle_count(uicore, os);
    chess_report_signed(val[0], os);
    os << std::endl;
    return chkapi_OK;
}

struct Chess_report_fn {
    const char* type_nm;
    checkers_chess_report_ptr report_fn;
};

static Chess_report_fn crfns[] = {
    { "bool", [=getdesign_name=]_chess_report_bool },
    { "__cchar", [=getdesign_name=]_chess_report___cchar },
    { "__schar", [=getdesign_name=]_chess_report___schar },
    { "__uchar", [=getdesign_name=]_chess_report___uchar },
    { "__sshort", [=getdesign_name=]_chess_report___sshort },
    { "__ushort", [=getdesign_name=]_chess_report___ushort },
    { "__sint", [=getdesign_name=]_chess_report___sint },
    { "__uint", [=getdesign_name=]_chess_report___uint },
    { "__slong", [=getdesign_name=]_chess_report___slong },
    { "__ulong", [=getdesign_name=]_chess_report___ulong },
    { "__slonglong", [=getdesign_name=]_chess_report___slonglong },
    { "__ulonglong", [=getdesign_name=]_chess_report___ulonglong },
    { "__ffloat", [=getdesign_name=]_chess_report___ffloat },
    { "__fdouble", [=getdesign_name=]_chess_report___fdouble },
    { "__flongdouble", [=getdesign_name=]_chess_report___flongdouble },
    { "__Pvoid", [=getdesign_name=]_chess_report___Pvoid },
    { "__PPMbvoid", [=getdesign_name=]_chess_report___PPMbvoid },
    { "__PPMvoid", [=getdesign_name=]_chess_report___PPMvoid },
    { "__PDMbvoid", [=getdesign_name=]_chess_report___PDMbvoid },
    { "__PDMhvoid", [=getdesign_name=]_chess_report___PDMhvoid },
    { "__PDMwvoid", [=getdesign_name=]_chess_report___PDMwvoid },
    { "__PDMb_statvoid", [=getdesign_name=]_chess_report___PDMb_statvoid },
    { "__PDMh_statvoid", [=getdesign_name=]_chess_report___PDMh_statvoid },
    { "__PDMw_statvoid", [=getdesign_name=]_chess_report___PDMw_statvoid },
    { "w32", [=getdesign_name=]_chess_report_w32 },
    { "int16p", [=getdesign_name=]_chess_report_int16p },
    { 0, 0 } /* sentinel */
};


//------- Type-specific chess_return_value functions -------

int [=getdesign_name=]_chess_return_value___cchar(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(8, 1, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___cchar");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___schar(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(8, 1, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___schar");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___uchar(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(8, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___uchar");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___sshort(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(16, 1, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___sshort");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___ushort(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(16, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___ushort");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___sint(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 1, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___sint");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___uint(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___uint");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___slong(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 1, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___slong");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___ulong(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___ulong");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___slonglong(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(64, 1, 0);
    int rt = chkapi_OK;
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    DataType vbit_component0(32, 0, 0);
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit_component0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_return_value record value", "[=getdesign_name=]_chess_return_value___slonglong");
    vbit.deposit(vbit_component0, 63, 32);
    // component 1 : 32 bits at 0
    DataType vbit_component1(32, 0, 0);
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(51), at_addr), vbit_component1);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_return_value record value", "[=getdesign_name=]_chess_return_value___slonglong");
    vbit.deposit(vbit_component1, 31, 0);
    /* complete */
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___ulonglong(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(64, 0, 0);
    int rt = chkapi_OK;
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    DataType vbit_component0(32, 0, 0);
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit_component0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_return_value record value", "[=getdesign_name=]_chess_return_value___ulonglong");
    vbit.deposit(vbit_component0, 63, 32);
    // component 1 : 32 bits at 0
    DataType vbit_component1(32, 0, 0);
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(51), at_addr), vbit_component1);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_return_value record value", "[=getdesign_name=]_chess_return_value___ulonglong");
    vbit.deposit(vbit_component1, 31, 0);
    /* complete */
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___ffloat(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 1, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___ffloat");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___fdouble(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(64, 1, 0);
    int rt = chkapi_OK;
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    DataType vbit_component0(32, 0, 0);
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit_component0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_return_value record value", "[=getdesign_name=]_chess_return_value___fdouble");
    vbit.deposit(vbit_component0, 63, 32);
    // component 1 : 32 bits at 0
    DataType vbit_component1(32, 0, 0);
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(51), at_addr), vbit_component1);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_return_value record value", "[=getdesign_name=]_chess_return_value___fdouble");
    vbit.deposit(vbit_component1, 31, 0);
    /* complete */
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___flongdouble(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(64, 1, 0);
    int rt = chkapi_OK;
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    DataType vbit_component0(32, 0, 0);
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit_component0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 0 of chess_return_value record value", "[=getdesign_name=]_chess_return_value___flongdouble");
    vbit.deposit(vbit_component0, 63, 32);
    // component 1 : 32 bits at 0
    DataType vbit_component1(32, 0, 0);
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(51), at_addr), vbit_component1);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read component 1 of chess_return_value record value", "[=getdesign_name=]_chess_return_value___flongdouble");
    vbit.deposit(vbit_component1, 31, 0);
    /* complete */
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___Pvoid(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___Pvoid");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___PPMbvoid(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___PPMbvoid");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___PPMvoid(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___PPMvoid");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___PDMbvoid(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___PDMbvoid");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___PDMhvoid(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___PDMhvoid");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___PDMwvoid(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___PDMwvoid");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___PDMb_statvoid(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___PDMb_statvoid");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___PDMh_statvoid(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___PDMh_statvoid");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value___PDMw_statvoid(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 0, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value___PDMw_statvoid");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value_w32(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(32, 1, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value_w32");
    ovbit = vbit;
    return chkapi_OK;
}

int [=getdesign_name=]_chess_return_value_int16p(Checkers_uicore* uicore, DataType& ovbit)
{
    DataType vbit(16, 1, 0);
    int rt = chkapi_OK;
    rt = chkapi_l_storage_get_vbit(uicore, Checkers_stor_addr(chess_[=getdesign_name=]_R_si, AddressType(41), at_addr), vbit);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_return_value value", "[=getdesign_name=]_chess_return_value_int16p");
    ovbit = vbit;
    return chkapi_OK;
}

struct Chess_return_value_fn {
    const char* type_nm;
    checkers_chess_return_value_ptr return_value_fn;
};

static Chess_return_value_fn cvfns[] = {
    { "__cchar", [=getdesign_name=]_chess_return_value___cchar },
    { "__schar", [=getdesign_name=]_chess_return_value___schar },
    { "__uchar", [=getdesign_name=]_chess_return_value___uchar },
    { "__sshort", [=getdesign_name=]_chess_return_value___sshort },
    { "__ushort", [=getdesign_name=]_chess_return_value___ushort },
    { "__sint", [=getdesign_name=]_chess_return_value___sint },
    { "__uint", [=getdesign_name=]_chess_return_value___uint },
    { "__slong", [=getdesign_name=]_chess_return_value___slong },
    { "__ulong", [=getdesign_name=]_chess_return_value___ulong },
    { "__slonglong", [=getdesign_name=]_chess_return_value___slonglong },
    { "__ulonglong", [=getdesign_name=]_chess_return_value___ulonglong },
    { "__ffloat", [=getdesign_name=]_chess_return_value___ffloat },
    { "__fdouble", [=getdesign_name=]_chess_return_value___fdouble },
    { "__flongdouble", [=getdesign_name=]_chess_return_value___flongdouble },
    { "__Pvoid", [=getdesign_name=]_chess_return_value___Pvoid },
    { "__PPMbvoid", [=getdesign_name=]_chess_return_value___PPMbvoid },
    { "__PPMvoid", [=getdesign_name=]_chess_return_value___PPMvoid },
    { "__PDMbvoid", [=getdesign_name=]_chess_return_value___PDMbvoid },
    { "__PDMhvoid", [=getdesign_name=]_chess_return_value___PDMhvoid },
    { "__PDMwvoid", [=getdesign_name=]_chess_return_value___PDMwvoid },
    { "__PDMb_statvoid", [=getdesign_name=]_chess_return_value___PDMb_statvoid },
    { "__PDMh_statvoid", [=getdesign_name=]_chess_return_value___PDMh_statvoid },
    { "__PDMw_statvoid", [=getdesign_name=]_chess_return_value___PDMw_statvoid },
    { "w32", [=getdesign_name=]_chess_return_value_w32 },
    { "int16p", [=getdesign_name=]_chess_return_value_int16p },
    { 0, 0 } /* sentinel */
};


//------- chess_cycle_count function -------

// return type on [=getdesign_name=] : unsigned long long (largest suitable)
int [=getdesign_name=]_chess_cycle_count(Checkers_uicore* uicore, long long val)
{
    long long fval = 0;
    int rt;
    /* keep_in_registers representation */
    // component 0 : 32 bits at 32
    fval = CHESS_MASKLL(val >> 32,32);
    rt = [=getdesign_name=]_write0(uicore, &fval,1, chess_[=getdesign_name=]_R_si, AddressType(2));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write component 0 of chess_cycle_count record value", "[=getdesign_name=]_chess_cycle_count");
    // component 1 : 32 bits at 0
    fval = CHESS_MASKLL(val >> 0,32);
    rt = [=getdesign_name=]_write0(uicore, &fval,1, chess_[=getdesign_name=]_R_si, AddressType(3));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write component 1 of chess_cycle_count record value", "[=getdesign_name=]_chess_cycle_count");
    /* complete */
    return chkapi_OK;
}


//------- chess_exit function -------

int [=getdesign_name=]_chess_exit___sint(Checkers_uicore* uicore, int& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(2));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_exit value", "[=getdesign_name=]_chess_exit___sint");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    val[0] = CHESS_EXTENDLL(val[0],32);
    oval = val[0];
    return chkapi_OK;
}


//------- chess_hosted_io function -------

int [=getdesign_name=]_chess_hosted_io___Pvoid(Checkers_uicore* uicore, AddressType& oval)
{
    long long val[1] = {0};
    int rt;
    long long fval[1] = {0};
    rt = [=getdesign_name=]_read0(uicore, fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read chess_hosted_io value", "[=getdesign_name=]_chess_hosted_io___Pvoid");
    val[0] |= CHESS_MASKLL(fval[0], 32) << 0;
    oval = val[0];
    return chkapi_OK;
}


//------- Passing argc/argv arguments to main -------

int [=getdesign_name=]_write_main_argc_argv(Checkers_uicore* uicore, long long argc, AddressType argv)
{
    AddressType val;
    long long fval = 0;
    int rt;
    val = argc;
    fval = CHESS_EXTENDLL(val >> 0,32);
    rt = [=getdesign_name=]_write0(uicore, &fval,1, chess_[=getdesign_name=]_R_si, AddressType(4));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write main argc value", "[=getdesign_name=]_write_main_argc_argv");
    val = argv;
    fval = CHESS_MASKLL(val >> 0,32);
    rt = [=getdesign_name=]_write0(uicore, &fval,1, chess_[=getdesign_name=]_R_si, AddressType(5));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write main argv value", "[=getdesign_name=]_write_main_argc_argv");
    return chkapi_OK;
}

int [=getdesign_name=]_argv_write_string(Checkers_uicore* uicore, std::string val, AddressType& addr)
{
    int rt = [=getdesign_name=]_writestring_DMb(uicore, val, addr, 1);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write argv string", "[=getdesign_name=]_argv_write_string");
    addr += (val.length() + 1) * 1;
    return chkapi_OK;
}

int [=getdesign_name=]_argv_write_ptr(Checkers_uicore* uicore, unsigned long long val, AddressType& addr)
{
    long long tval = val;
    int rt = [=getdesign_name=]_write0_DMw(uicore, &tval,1, chess_[=getdesign_name=]_DMb_si, addr);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write argv pointer", "[=getdesign_name=]_argv_write_ptr");
    addr += 4;
    return chkapi_OK;
}

int [=getdesign_name=]_argv_align_ptr(Checkers_uicore* uicore, AddressType& addr)
{
    if (addr % 4 != 0) addr += 4 - addr % 4;
    return chkapi_OK;
}


//------- IO hosting via stdio.h functions -------

// The arguments to the stdio.h functions are collected on the [=getdesign_name=] target
// in a local struct (in stack memory `DMb'),
// the base address of which is passed to each function.


// Read/write functions for stdio.h function arguments

int [=getdesign_name=]_read_call_type(Checkers_uicore* uicore, int& id, AddressType hcvars)
{
    long long val = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, hcvars + 0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read call type", "[=getdesign_name=]_read_call_type");
    id = (int)val;
    return chkapi_OK;
}

int [=getdesign_name=]_read_stream_id(Checkers_uicore* uicore, int& id, AddressType hcvars)
{
    long long val = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, hcvars + 4);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read stream id", "[=getdesign_name=]_read_stream_id");
    id = (int)val;
    return chkapi_OK;
}

int [=getdesign_name=]_read_path(Checkers_uicore* uicore, std::string& path, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 12);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read path pointer", "[=getdesign_name=]_read_path");
    ptr = CHESS_MASKLL(ptr,32);
    rt = [=getdesign_name=]_readstring_DMb(uicore, path, AddressType(ptr));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read path string", "[=getdesign_name=]_read_path");
    return chkapi_OK;
}

int [=getdesign_name=]_read_mode(Checkers_uicore* uicore, std::string& mode, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 16);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read mode pointer", "[=getdesign_name=]_read_mode");
    ptr = CHESS_MASKLL(ptr,32);
    rt = [=getdesign_name=]_readstring_DMb(uicore, mode, AddressType(ptr));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read mode string", "[=getdesign_name=]_read_mode");
    return chkapi_OK;
}

int [=getdesign_name=]_read_format(Checkers_uicore* uicore, std::string& format, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 20);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read format pointer", "[=getdesign_name=]_read_format");
    ptr = CHESS_MASKLL(ptr,32);
    rt = [=getdesign_name=]_readstring_DMb(uicore, format, AddressType(ptr));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read format string", "[=getdesign_name=]_read_format");
    return chkapi_OK;
}

int [=getdesign_name=]_read_offset(Checkers_uicore* uicore, long& offset, AddressType hcvars)
{
    long long val = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, hcvars + 24);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read offset", "[=getdesign_name=]_read_offset");
    offset = (long)val;
    return chkapi_OK;
}

int [=getdesign_name=]_read_whence(Checkers_uicore* uicore, int& whence, AddressType hcvars)
{
    long long val = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, hcvars + 28);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read whence", "[=getdesign_name=]_read_whence");
    whence = (int)val;
    return chkapi_OK;
}

int [=getdesign_name=]_read_c(Checkers_uicore* uicore, int& c, AddressType hcvars)
{
    long long val = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, hcvars + 36);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read c", "[=getdesign_name=]_read_c");
    c = (int)val;
    return chkapi_OK;
}

int [=getdesign_name=]_read_s(Checkers_uicore* uicore, std::string& s, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 40);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read s pointer", "[=getdesign_name=]_read_s");
    ptr = CHESS_MASKLL(ptr,32);
    rt = [=getdesign_name=]_readstring_DMb(uicore, s, AddressType(ptr));
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read s string", "[=getdesign_name=]_read_s");
    return chkapi_OK;
}

int [=getdesign_name=]_read_size(Checkers_uicore* uicore, int& size, AddressType hcvars)
{
    long long val = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, hcvars + 48);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read size", "[=getdesign_name=]_read_size");
    val = CHESS_MASKLL(val,32);
    size = (unsigned)val;
    return chkapi_OK;
}

int [=getdesign_name=]_read_nmemb(Checkers_uicore* uicore, int& nmemb, AddressType hcvars)
{
    long long val = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, hcvars + 52);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read nmemb", "[=getdesign_name=]_read_nmemb");
    val = CHESS_MASKLL(val,32);
    nmemb = (unsigned)val;
    return chkapi_OK;
}

int [=getdesign_name=]_read_ap(Checkers_uicore* uicore, AddressType& ap, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 64);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read ap", "[=getdesign_name=]_read_ap");
    ptr = CHESS_MASKLL(ptr,32);
    ap = (AddressType)ptr;
    return chkapi_OK;
}

int [=getdesign_name=]_write_call_type(Checkers_uicore* uicore, int id, AddressType hcvars)
{
    long long tval = id;
    int rt = [=getdesign_name=]_write0_DMw(uicore, &tval,1, chess_[=getdesign_name=]_DMb_si, hcvars + 0);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write call type", "[=getdesign_name=]_write_call_type");
    return chkapi_OK;
}

int [=getdesign_name=]_write_stream_id(Checkers_uicore* uicore, int id, AddressType hcvars)
{
    long long tval = id;
    int rt = [=getdesign_name=]_write0_DMw(uicore, &tval,1, chess_[=getdesign_name=]_DMb_si, hcvars + 4);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write stream id", "[=getdesign_name=]_write_stream_id");
    return chkapi_OK;
}

int [=getdesign_name=]_write_stream_rt(Checkers_uicore* uicore, int rtv, AddressType hcvars)
{
    long long tval = rtv;
    int rt = [=getdesign_name=]_write0_DMw(uicore, &tval,1, chess_[=getdesign_name=]_DMb_si, hcvars + 8);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write stream return value", "[=getdesign_name=]_write_stream_rt");
    return chkapi_OK;
}

int [=getdesign_name=]_write_offset(Checkers_uicore* uicore, long offset, AddressType hcvars)
{
    long long tval = offset;
    int rt = [=getdesign_name=]_write0_DMw(uicore, &tval,1, chess_[=getdesign_name=]_DMb_si, hcvars + 24);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write offset", "[=getdesign_name=]_write_offset");
    return chkapi_OK;
}

int [=getdesign_name=]_write_eof(Checkers_uicore* uicore, int eof, AddressType hcvars)
{
    long long tval = eof;
    int rt = [=getdesign_name=]_write0_DMw(uicore, &tval,1, chess_[=getdesign_name=]_DMb_si, hcvars + 32);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write eof", "[=getdesign_name=]_write_eof");
    return chkapi_OK;
}

int [=getdesign_name=]_write_s(Checkers_uicore* uicore, std::string s, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 44);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read s pointer", "[=getdesign_name=]_write_s");
    ptr = CHESS_MASKLL(ptr,32);
    rt = [=getdesign_name=]_writestring_DMb(uicore, s, AddressType(ptr), 1);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write s string", "[=getdesign_name=]_write_s");
    return chkapi_OK;
}

int [=getdesign_name=]_write_s_with_size(Checkers_uicore* uicore, const char* s, int sz, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 44);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read s pointer", "[=getdesign_name=]_write_s_with_size");
    ptr = CHESS_MASKLL(ptr,32);
    rt = [=getdesign_name=]_writestring_DMb(uicore, s, sz, AddressType(ptr), 1);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write s string", "[=getdesign_name=]_write_s_with_size");
    return chkapi_OK;
}

int [=getdesign_name=]_write_size(Checkers_uicore* uicore, int size, AddressType hcvars)
{
    long long tval = size;
    int rt = [=getdesign_name=]_write0_DMw(uicore, &tval,1, chess_[=getdesign_name=]_DMb_si, hcvars + 48);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not write size", "[=getdesign_name=]_write_size");
    return chkapi_OK;
}

// Memory-specific binary fread/fwrite functions:
// in general `nmemb' memory locations, each `size' bytes (lsb or msb first);
// or simple unsigned byte per memory location, `size*nmemb' locations

int [=getdesign_name=]_read_word_ptr_PMb(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_word_ptr_PMb");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_PMb_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read word from data pointer (output to host)", "[=getdesign_name=]_read_word_ptr_PMb");
        if (lsb_first)
            for(int j = 0; j < size; j++)
                dta.push_back(val >> j*8 & 0xff);
        else
            for(int j = size-1; j >= 0; j--)
                dta.push_back(val >> j*8 & 0xff);
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_word_ptr_PMb(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_word_ptr_PMb");
    ptr = CHESS_MASKLL(ptr,32);
    std::vector<unsigned char>::const_iterator i = dta.begin();
    while (i != dta.end()) {
        long long val = 0;
        if (lsb_first)
            for(int j = 0; j < size && i != dta.end(); j++, i++)
                val |= (long long)*i << j*8;
        else
            for(int j = size-1; j >= 0 && i != dta.end(); j--, i++)
                val |= (long long)*i << j*8;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_PMb_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write word to data pointer (input from host)", "[=getdesign_name=]_write_word_ptr_PMb");
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_ptr_PMb(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_read_word_ptr_PMb(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_ptr_PMb");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < size*nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_PMb_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read byte from data pointer (output to host)", "[=getdesign_name=]_read_ptr_PMb");
        dta.push_back(val & 0xff);
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_ptr_PMb(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_write_word_ptr_PMb(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_ptr_PMb");
    ptr = CHESS_MASKLL(ptr,32);
    typedef std::vector<unsigned char>::const_iterator ucI;
    for (ucI i = dta.begin(); i != dta.end(); i++) {
        long long val = *i;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_PMb_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write byte to data pointer (input from host)", "[=getdesign_name=]_write_ptr_PMb");
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_word_ptr_PM(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_word_ptr_PM");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_PM_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read word from data pointer (output to host)", "[=getdesign_name=]_read_word_ptr_PM");
        if (lsb_first)
            for(int j = 0; j < size; j++)
                dta.push_back(val >> j*8 & 0xff);
        else
            for(int j = size-1; j >= 0; j--)
                dta.push_back(val >> j*8 & 0xff);
        ptr += 4;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_word_ptr_PM(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_word_ptr_PM");
    ptr = CHESS_MASKLL(ptr,32);
    std::vector<unsigned char>::const_iterator i = dta.begin();
    while (i != dta.end()) {
        long long val = 0;
        if (lsb_first)
            for(int j = 0; j < size && i != dta.end(); j++, i++)
                val |= (long long)*i << j*8;
        else
            for(int j = size-1; j >= 0 && i != dta.end(); j--, i++)
                val |= (long long)*i << j*8;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_PM_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write word to data pointer (input from host)", "[=getdesign_name=]_write_word_ptr_PM");
        ptr += 4;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_ptr_PM(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_read_word_ptr_PM(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_ptr_PM");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < size*nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_PM_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read byte from data pointer (output to host)", "[=getdesign_name=]_read_ptr_PM");
        dta.push_back(val & 0xff);
        ptr += 4;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_ptr_PM(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_write_word_ptr_PM(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_ptr_PM");
    ptr = CHESS_MASKLL(ptr,32);
    typedef std::vector<unsigned char>::const_iterator ucI;
    for (ucI i = dta.begin(); i != dta.end(); i++) {
        long long val = *i;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_PM_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write byte to data pointer (input from host)", "[=getdesign_name=]_write_ptr_PM");
        ptr += 4;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_word_ptr_DMb(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_word_ptr_DMb");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read word from data pointer (output to host)", "[=getdesign_name=]_read_word_ptr_DMb");
        if (lsb_first)
            for(int j = 0; j < size; j++)
                dta.push_back(val >> j*8 & 0xff);
        else
            for(int j = size-1; j >= 0; j--)
                dta.push_back(val >> j*8 & 0xff);
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_word_ptr_DMb(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_word_ptr_DMb");
    ptr = CHESS_MASKLL(ptr,32);
    std::vector<unsigned char>::const_iterator i = dta.begin();
    while (i != dta.end()) {
        long long val = 0;
        if (lsb_first)
            for(int j = 0; j < size && i != dta.end(); j++, i++)
                val |= (long long)*i << j*8;
        else
            for(int j = size-1; j >= 0 && i != dta.end(); j--, i++)
                val |= (long long)*i << j*8;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write word to data pointer (input from host)", "[=getdesign_name=]_write_word_ptr_DMb");
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_ptr_DMb(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_read_word_ptr_DMb(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_ptr_DMb");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < size*nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read byte from data pointer (output to host)", "[=getdesign_name=]_read_ptr_DMb");
        dta.push_back(val & 0xff);
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_ptr_DMb(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_write_word_ptr_DMb(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_ptr_DMb");
    ptr = CHESS_MASKLL(ptr,32);
    typedef std::vector<unsigned char>::const_iterator ucI;
    for (ucI i = dta.begin(); i != dta.end(); i++) {
        long long val = *i;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write byte to data pointer (input from host)", "[=getdesign_name=]_write_ptr_DMb");
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_word_ptr_DMh(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_word_ptr_DMh");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMh_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read word from data pointer (output to host)", "[=getdesign_name=]_read_word_ptr_DMh");
        if (lsb_first)
            for(int j = 0; j < size; j++)
                dta.push_back(val >> j*8 & 0xff);
        else
            for(int j = size-1; j >= 0; j--)
                dta.push_back(val >> j*8 & 0xff);
        ptr += 2;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_word_ptr_DMh(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_word_ptr_DMh");
    ptr = CHESS_MASKLL(ptr,32);
    std::vector<unsigned char>::const_iterator i = dta.begin();
    while (i != dta.end()) {
        long long val = 0;
        if (lsb_first)
            for(int j = 0; j < size && i != dta.end(); j++, i++)
                val |= (long long)*i << j*8;
        else
            for(int j = size-1; j >= 0 && i != dta.end(); j--, i++)
                val |= (long long)*i << j*8;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMh_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write word to data pointer (input from host)", "[=getdesign_name=]_write_word_ptr_DMh");
        ptr += 2;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_ptr_DMh(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_read_word_ptr_DMh(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_ptr_DMh");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < size*nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMh_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read byte from data pointer (output to host)", "[=getdesign_name=]_read_ptr_DMh");
        dta.push_back(val & 0xff);
        ptr += 2;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_ptr_DMh(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_write_word_ptr_DMh(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_ptr_DMh");
    ptr = CHESS_MASKLL(ptr,32);
    typedef std::vector<unsigned char>::const_iterator ucI;
    for (ucI i = dta.begin(); i != dta.end(); i++) {
        long long val = *i;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMh_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write byte to data pointer (input from host)", "[=getdesign_name=]_write_ptr_DMh");
        ptr += 2;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_word_ptr_DMw(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_word_ptr_DMw");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMw_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read word from data pointer (output to host)", "[=getdesign_name=]_read_word_ptr_DMw");
        if (lsb_first)
            for(int j = 0; j < size; j++)
                dta.push_back(val >> j*8 & 0xff);
        else
            for(int j = size-1; j >= 0; j--)
                dta.push_back(val >> j*8 & 0xff);
        ptr += 4;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_word_ptr_DMw(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_word_ptr_DMw");
    ptr = CHESS_MASKLL(ptr,32);
    std::vector<unsigned char>::const_iterator i = dta.begin();
    while (i != dta.end()) {
        long long val = 0;
        if (lsb_first)
            for(int j = 0; j < size && i != dta.end(); j++, i++)
                val |= (long long)*i << j*8;
        else
            for(int j = size-1; j >= 0 && i != dta.end(); j--, i++)
                val |= (long long)*i << j*8;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMw_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write word to data pointer (input from host)", "[=getdesign_name=]_write_word_ptr_DMw");
        ptr += 4;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_ptr_DMw(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_read_word_ptr_DMw(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_ptr_DMw");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < size*nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMw_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read byte from data pointer (output to host)", "[=getdesign_name=]_read_ptr_DMw");
        dta.push_back(val & 0xff);
        ptr += 4;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_ptr_DMw(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_write_word_ptr_DMw(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_ptr_DMw");
    ptr = CHESS_MASKLL(ptr,32);
    typedef std::vector<unsigned char>::const_iterator ucI;
    for (ucI i = dta.begin(); i != dta.end(); i++) {
        long long val = *i;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMw_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write byte to data pointer (input from host)", "[=getdesign_name=]_write_ptr_DMw");
        ptr += 4;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_word_ptr_DMb_stat(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_word_ptr_DMb_stat");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read word from data pointer (output to host)", "[=getdesign_name=]_read_word_ptr_DMb_stat");
        if (lsb_first)
            for(int j = 0; j < size; j++)
                dta.push_back(val >> j*8 & 0xff);
        else
            for(int j = size-1; j >= 0; j--)
                dta.push_back(val >> j*8 & 0xff);
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_word_ptr_DMb_stat(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_word_ptr_DMb_stat");
    ptr = CHESS_MASKLL(ptr,32);
    std::vector<unsigned char>::const_iterator i = dta.begin();
    while (i != dta.end()) {
        long long val = 0;
        if (lsb_first)
            for(int j = 0; j < size && i != dta.end(); j++, i++)
                val |= (long long)*i << j*8;
        else
            for(int j = size-1; j >= 0 && i != dta.end(); j--, i++)
                val |= (long long)*i << j*8;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write word to data pointer (input from host)", "[=getdesign_name=]_write_word_ptr_DMb_stat");
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_ptr_DMb_stat(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_read_word_ptr_DMb_stat(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_ptr_DMb_stat");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < size*nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMb_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read byte from data pointer (output to host)", "[=getdesign_name=]_read_ptr_DMb_stat");
        dta.push_back(val & 0xff);
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_ptr_DMb_stat(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_write_word_ptr_DMb_stat(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_ptr_DMb_stat");
    ptr = CHESS_MASKLL(ptr,32);
    typedef std::vector<unsigned char>::const_iterator ucI;
    for (ucI i = dta.begin(); i != dta.end(); i++) {
        long long val = *i;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMb_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write byte to data pointer (input from host)", "[=getdesign_name=]_write_ptr_DMb_stat");
        ptr += 1;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_word_ptr_DMh_stat(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_word_ptr_DMh_stat");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMh_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read word from data pointer (output to host)", "[=getdesign_name=]_read_word_ptr_DMh_stat");
        if (lsb_first)
            for(int j = 0; j < size; j++)
                dta.push_back(val >> j*8 & 0xff);
        else
            for(int j = size-1; j >= 0; j--)
                dta.push_back(val >> j*8 & 0xff);
        ptr += 2;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_word_ptr_DMh_stat(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_word_ptr_DMh_stat");
    ptr = CHESS_MASKLL(ptr,32);
    std::vector<unsigned char>::const_iterator i = dta.begin();
    while (i != dta.end()) {
        long long val = 0;
        if (lsb_first)
            for(int j = 0; j < size && i != dta.end(); j++, i++)
                val |= (long long)*i << j*8;
        else
            for(int j = size-1; j >= 0 && i != dta.end(); j--, i++)
                val |= (long long)*i << j*8;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMh_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write word to data pointer (input from host)", "[=getdesign_name=]_write_word_ptr_DMh_stat");
        ptr += 2;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_ptr_DMh_stat(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_read_word_ptr_DMh_stat(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_ptr_DMh_stat");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < size*nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMh_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read byte from data pointer (output to host)", "[=getdesign_name=]_read_ptr_DMh_stat");
        dta.push_back(val & 0xff);
        ptr += 2;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_ptr_DMh_stat(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_write_word_ptr_DMh_stat(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_ptr_DMh_stat");
    ptr = CHESS_MASKLL(ptr,32);
    typedef std::vector<unsigned char>::const_iterator ucI;
    for (ucI i = dta.begin(); i != dta.end(); i++) {
        long long val = *i;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMh_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write byte to data pointer (input from host)", "[=getdesign_name=]_write_ptr_DMh_stat");
        ptr += 2;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_word_ptr_DMw_stat(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_word_ptr_DMw_stat");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMw_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read word from data pointer (output to host)", "[=getdesign_name=]_read_word_ptr_DMw_stat");
        if (lsb_first)
            for(int j = 0; j < size; j++)
                dta.push_back(val >> j*8 & 0xff);
        else
            for(int j = size-1; j >= 0; j--)
                dta.push_back(val >> j*8 & 0xff);
        ptr += 4;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_word_ptr_DMw_stat(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, int lsb_first, AddressType hcvars)
{
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_word_ptr_DMw_stat");
    ptr = CHESS_MASKLL(ptr,32);
    std::vector<unsigned char>::const_iterator i = dta.begin();
    while (i != dta.end()) {
        long long val = 0;
        if (lsb_first)
            for(int j = 0; j < size && i != dta.end(); j++, i++)
                val |= (long long)*i << j*8;
        else
            for(int j = size-1; j >= 0 && i != dta.end(); j--, i++)
                val |= (long long)*i << j*8;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMw_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write word to data pointer (input from host)", "[=getdesign_name=]_write_word_ptr_DMw_stat");
        ptr += 4;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_read_ptr_DMw_stat(Checkers_uicore* uicore, std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_read_word_ptr_DMw_stat(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 56);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for reading output to host)", "[=getdesign_name=]_read_ptr_DMw_stat");
    ptr = CHESS_MASKLL(ptr,32);
    for (int i = 0; i < size*nmemb; i++) {
        long long val = 0;
        rt = [=getdesign_name=]_read0(uicore, &val,1, chess_[=getdesign_name=]_DMw_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not read byte from data pointer (output to host)", "[=getdesign_name=]_read_ptr_DMw_stat");
        dta.push_back(val & 0xff);
        ptr += 4;
    }
    return chkapi_OK;
}

int [=getdesign_name=]_write_ptr_DMw_stat(Checkers_uicore* uicore, const std::vector<unsigned char>& dta, int size, int nmemb, AddressType hcvars)
{
    //return [=getdesign_name=]_write_word_ptr_DMw_stat(uicore, dta, 1, size*nmemb, 0, hcvars);
    long long ptr = 0;
    int rt = [=getdesign_name=]_read0_DMw(uicore, &ptr,1, chess_[=getdesign_name=]_DMb_si, hcvars + 60);
    if (rt != chkapi_OK)
        return uicore->errors.put(rt, "Could not read data pointer (for writing input from host)", "[=getdesign_name=]_write_ptr_DMw_stat");
    ptr = CHESS_MASKLL(ptr,32);
    typedef std::vector<unsigned char>::const_iterator ucI;
    for (ucI i = dta.begin(); i != dta.end(); i++) {
        long long val = *i;
        rt = [=getdesign_name=]_write0(uicore, &val,1, chess_[=getdesign_name=]_DMw_stat_si, AddressType(ptr));
        if (rt != chkapi_OK)
            return uicore->errors.put(rt, "Could not write byte to data pointer (input from host)", "[=getdesign_name=]_write_ptr_DMw_stat");
        ptr += 4;
    }
    return chkapi_OK;
}


// Constants as used on the target (override defaults if needed)

#ifndef EOF
# define EOF (-1)
#endif

#ifndef EBADF
# define EBADF 9
#endif

#ifndef SEEK_SET
# define SEEK_SET 0
#endif

#ifndef SEEK_CUR
# define SEEK_CUR 1
#endif

#ifndef SEEK_END
# define SEEK_END 2
#endif

// IO hosting hook

int [=getdesign_name=]_uicore::hosted_clib_init()
{
    // Initialise all existing get functions
    hc_getf    .get_int                    = [=getdesign_name=]_get_DMb___sint;
    hc_getf_alt.get_int                    = [=getdesign_name=]_getalt_DMb___sint;
    hc_getf    .get_long_int               = [=getdesign_name=]_get_DMb___slong;
    hc_getf_alt.get_long_int               = [=getdesign_name=]_getalt_DMb___slong;
    hc_getf    .get_long_long_int          = [=getdesign_name=]_get_DMb___slonglong;
    hc_getf_alt.get_long_long_int          = [=getdesign_name=]_getalt_DMb___slonglong;
    hc_getf    .get_short_int              = [=getdesign_name=]_getp_DMb___sshort;
    hc_getf_alt.get_short_int              = [=getdesign_name=]_getpalt_DMb___sshort;
    hc_getf    .get_signed_char            = [=getdesign_name=]_getp_DMb___schar;
    hc_getf_alt.get_signed_char            = [=getdesign_name=]_getpalt_DMb___schar;
    hc_getf    .get_intmax_t               = [=getdesign_name=]_get_DMb___slonglong;
    hc_getf_alt.get_intmax_t               = [=getdesign_name=]_getalt_DMb___slonglong;
    hc_getf    .get_ssize_t                = [=getdesign_name=]_get_DMb___sint;
    hc_getf_alt.get_ssize_t                = [=getdesign_name=]_getalt_DMb___sint;
    hc_getf    .get_ptrdiff_t              = [=getdesign_name=]_get_DMb___sint;
    hc_getf_alt.get_ptrdiff_t              = [=getdesign_name=]_getalt_DMb___sint;
    hc_getf    .get_unsigned_int           = [=getdesign_name=]_get_DMb___uint;
    hc_getf_alt.get_unsigned_int           = [=getdesign_name=]_getalt_DMb___uint;
    hc_getf    .get_unsigned_long_int      = [=getdesign_name=]_get_DMb___ulong;
    hc_getf_alt.get_unsigned_long_int      = [=getdesign_name=]_getalt_DMb___ulong;
    hc_getf    .get_unsigned_long_long_int = [=getdesign_name=]_get_DMb___ulonglong;
    hc_getf_alt.get_unsigned_long_long_int = [=getdesign_name=]_getalt_DMb___ulonglong;
    hc_getf    .get_unsigned_short_int     = [=getdesign_name=]_getp_DMb___ushort;
    hc_getf_alt.get_unsigned_short_int     = [=getdesign_name=]_getpalt_DMb___ushort;
    hc_getf    .get_unsigned_char          = [=getdesign_name=]_getp_DMb___uchar;
    hc_getf_alt.get_unsigned_char          = [=getdesign_name=]_getpalt_DMb___uchar;
    hc_getf    .get_uintmax_t              = [=getdesign_name=]_get_DMb___ulonglong;
    hc_getf_alt.get_uintmax_t              = [=getdesign_name=]_getalt_DMb___ulonglong;
    hc_getf    .get_size_t                 = [=getdesign_name=]_get_DMb___uint;
    hc_getf_alt.get_size_t                 = [=getdesign_name=]_getalt_DMb___uint;
    hc_getf    .get_uptrdiff_t             = [=getdesign_name=]_get_DMb___uint;
    hc_getf_alt.get_uptrdiff_t             = [=getdesign_name=]_getalt_DMb___uint;
    hc_getf    .get_double                 = [=getdesign_name=]_gete_DMb___fdouble;
    hc_getf_alt.get_double                 = [=getdesign_name=]_getealt_DMb___fdouble;
    hc_getf    .get_long_double            = [=getdesign_name=]_gete_DMb___flongdouble;
    hc_getf_alt.get_long_double            = [=getdesign_name=]_getealt_DMb___flongdouble;
    hc_getf    .get_pointer                = [=getdesign_name=]_get_DMb___Pvoid;
    hc_getf_alt.get_pointer                = [=getdesign_name=]_getalt_DMb___Pvoid;
    hc_getf    .get_const_char_ptr         = [=getdesign_name=]_getstring_DMb;
    hc_getf_alt.get_const_char_ptr         = [=getdesign_name=]_getstringalt_DMb;
    // Initialise all existing put functions
    hc_putf    .put_int                    = [=getdesign_name=]_put_DMb___sint;
    hc_putf_alt.put_int                    = [=getdesign_name=]_putalt_DMb___sint;
    hc_putf    .put_long_int               = [=getdesign_name=]_put_DMb___slong;
    hc_putf_alt.put_long_int               = [=getdesign_name=]_putalt_DMb___slong;
    hc_putf    .put_long_long_int          = [=getdesign_name=]_put_DMb___slonglong;
    hc_putf_alt.put_long_long_int          = [=getdesign_name=]_putalt_DMb___slonglong;
    hc_putf    .put_short_int              = [=getdesign_name=]_put_DMb___sshort;
    hc_putf_alt.put_short_int              = [=getdesign_name=]_putalt_DMb___sshort;
    hc_putf    .put_signed_char            = [=getdesign_name=]_put_DMb___schar;
    hc_putf_alt.put_signed_char            = [=getdesign_name=]_putalt_DMb___schar;
    hc_putf    .put_intmax_t               = [=getdesign_name=]_put_DMb___slonglong;
    hc_putf_alt.put_intmax_t               = [=getdesign_name=]_putalt_DMb___slonglong;
    hc_putf    .put_ssize_t                = [=getdesign_name=]_put_DMb___sint;
    hc_putf_alt.put_ssize_t                = [=getdesign_name=]_putalt_DMb___sint;
    hc_putf    .put_ptrdiff_t              = [=getdesign_name=]_put_DMb___sint;
    hc_putf_alt.put_ptrdiff_t              = [=getdesign_name=]_putalt_DMb___sint;
    hc_putf    .put_unsigned_int           = [=getdesign_name=]_put_DMb___uint;
    hc_putf_alt.put_unsigned_int           = [=getdesign_name=]_putalt_DMb___uint;
    hc_putf    .put_unsigned_long_int      = [=getdesign_name=]_put_DMb___ulong;
    hc_putf_alt.put_unsigned_long_int      = [=getdesign_name=]_putalt_DMb___ulong;
    hc_putf    .put_unsigned_long_long_int = [=getdesign_name=]_put_DMb___ulonglong;
    hc_putf_alt.put_unsigned_long_long_int = [=getdesign_name=]_putalt_DMb___ulonglong;
    hc_putf    .put_unsigned_short_int     = [=getdesign_name=]_put_DMb___ushort;
    hc_putf_alt.put_unsigned_short_int     = [=getdesign_name=]_putalt_DMb___ushort;
    hc_putf    .put_unsigned_char          = [=getdesign_name=]_put_DMb___uchar;
    hc_putf_alt.put_unsigned_char          = [=getdesign_name=]_putalt_DMb___uchar;
    hc_putf    .put_uintmax_t              = [=getdesign_name=]_put_DMb___ulonglong;
    hc_putf_alt.put_uintmax_t              = [=getdesign_name=]_putalt_DMb___ulonglong;
    hc_putf    .put_size_t                 = [=getdesign_name=]_put_DMb___uint;
    hc_putf_alt.put_size_t                 = [=getdesign_name=]_putalt_DMb___uint;
    hc_putf    .put_uptrdiff_t             = [=getdesign_name=]_put_DMb___uint;
    hc_putf_alt.put_uptrdiff_t             = [=getdesign_name=]_putalt_DMb___uint;
    hc_putf    .put_float                  = [=getdesign_name=]_pute_DMb___ffloat;
    hc_putf_alt.put_float                  = [=getdesign_name=]_putealt_DMb___ffloat;
    hc_putf    .put_double                 = [=getdesign_name=]_pute_DMb___fdouble;
    hc_putf_alt.put_double                 = [=getdesign_name=]_putealt_DMb___fdouble;
    hc_putf    .put_long_double            = [=getdesign_name=]_pute_DMb___flongdouble;
    hc_putf_alt.put_long_double            = [=getdesign_name=]_putealt_DMb___flongdouble;
    hc_putf    .put_pointer                = [=getdesign_name=]_put_DMb___Pvoid;
    hc_putf_alt.put_pointer                = [=getdesign_name=]_putalt_DMb___Pvoid;
    hc_putf    .put_const_char_ptr         = [=getdesign_name=]_putstring_DMb;
    hc_putf_alt.put_const_char_ptr         = [=getdesign_name=]_putstringalt_DMb;
    // Constants as used on the target
    hc_intf.target_eof      = EOF;
    hc_intf.target_ebadf    = EBADF;
    hc_intf.target_seek_set = SEEK_SET;
    hc_intf.target_seek_cur = SEEK_CUR;
    hc_intf.target_seek_end = SEEK_END;
    // Initialise all interface functions
    hc_intf.read_call_type  = [=getdesign_name=]_read_call_type ;
    hc_intf.read_stream_id  = [=getdesign_name=]_read_stream_id ;
    hc_intf.read_path       = [=getdesign_name=]_read_path      ;
    hc_intf.read_mode       = [=getdesign_name=]_read_mode      ;
    hc_intf.read_format     = [=getdesign_name=]_read_format    ;
    hc_intf.read_offset     = [=getdesign_name=]_read_offset    ;
    hc_intf.read_whence     = [=getdesign_name=]_read_whence    ;
    hc_intf.read_c          = [=getdesign_name=]_read_c         ;
    hc_intf.read_s          = [=getdesign_name=]_read_s         ;
    hc_intf.read_size       = [=getdesign_name=]_read_size      ;
    hc_intf.read_nmemb      = [=getdesign_name=]_read_nmemb     ;
    hc_intf.read_ap         = [=getdesign_name=]_read_ap        ;
    hc_intf.write_call_type = [=getdesign_name=]_write_call_type;
    hc_intf.write_stream_id = [=getdesign_name=]_write_stream_id;
    hc_intf.write_stream_rt = [=getdesign_name=]_write_stream_rt;
    hc_intf.write_offset    = [=getdesign_name=]_write_offset   ;
    hc_intf.write_eof       = [=getdesign_name=]_write_eof      ;
    hc_intf.write_s         = [=getdesign_name=]_write_s        ;
    hc_intf.write_s_with_size = [=getdesign_name=]_write_s_with_size;
    hc_intf.write_size      = [=getdesign_name=]_write_size     ;
    // Initialise memory-specific binary fread/fwrite functions
    hc_intf.read_word_ptr_map ["PMb"] = [=getdesign_name=]_read_word_ptr_PMb;
    hc_intf.write_word_ptr_map["PMb"] = [=getdesign_name=]_write_word_ptr_PMb;
    hc_intf.read_ptr_map      ["PMb"] = [=getdesign_name=]_read_ptr_PMb;
    hc_intf.write_ptr_map     ["PMb"] = [=getdesign_name=]_write_ptr_PMb;
    hc_intf.read_word_ptr_map ["PM"] = [=getdesign_name=]_read_word_ptr_PM;
    hc_intf.write_word_ptr_map["PM"] = [=getdesign_name=]_write_word_ptr_PM;
    hc_intf.read_ptr_map      ["PM"] = [=getdesign_name=]_read_ptr_PM;
    hc_intf.write_ptr_map     ["PM"] = [=getdesign_name=]_write_ptr_PM;
    hc_intf.read_word_ptr_map ["DMb"] = [=getdesign_name=]_read_word_ptr_DMb;
    hc_intf.write_word_ptr_map["DMb"] = [=getdesign_name=]_write_word_ptr_DMb;
    hc_intf.read_ptr_map      ["DMb"] = [=getdesign_name=]_read_ptr_DMb;
    hc_intf.write_ptr_map     ["DMb"] = [=getdesign_name=]_write_ptr_DMb;
    hc_intf.read_word_ptr_map ["DMh"] = [=getdesign_name=]_read_word_ptr_DMh;
    hc_intf.write_word_ptr_map["DMh"] = [=getdesign_name=]_write_word_ptr_DMh;
    hc_intf.read_ptr_map      ["DMh"] = [=getdesign_name=]_read_ptr_DMh;
    hc_intf.write_ptr_map     ["DMh"] = [=getdesign_name=]_write_ptr_DMh;
    hc_intf.read_word_ptr_map ["DMw"] = [=getdesign_name=]_read_word_ptr_DMw;
    hc_intf.write_word_ptr_map["DMw"] = [=getdesign_name=]_write_word_ptr_DMw;
    hc_intf.read_ptr_map      ["DMw"] = [=getdesign_name=]_read_ptr_DMw;
    hc_intf.write_ptr_map     ["DMw"] = [=getdesign_name=]_write_ptr_DMw;
    hc_intf.read_word_ptr_map ["DMb_stat"] = [=getdesign_name=]_read_word_ptr_DMb_stat;
    hc_intf.write_word_ptr_map["DMb_stat"] = [=getdesign_name=]_write_word_ptr_DMb_stat;
    hc_intf.read_ptr_map      ["DMb_stat"] = [=getdesign_name=]_read_ptr_DMb_stat;
    hc_intf.write_ptr_map     ["DMb_stat"] = [=getdesign_name=]_write_ptr_DMb_stat;
    hc_intf.read_word_ptr_map ["DMh_stat"] = [=getdesign_name=]_read_word_ptr_DMh_stat;
    hc_intf.write_word_ptr_map["DMh_stat"] = [=getdesign_name=]_write_word_ptr_DMh_stat;
    hc_intf.read_ptr_map      ["DMh_stat"] = [=getdesign_name=]_read_ptr_DMh_stat;
    hc_intf.write_ptr_map     ["DMh_stat"] = [=getdesign_name=]_write_ptr_DMh_stat;
    hc_intf.read_word_ptr_map ["DMw_stat"] = [=getdesign_name=]_read_word_ptr_DMw_stat;
    hc_intf.write_word_ptr_map["DMw_stat"] = [=getdesign_name=]_write_word_ptr_DMw_stat;
    hc_intf.read_ptr_map      ["DMw_stat"] = [=getdesign_name=]_read_ptr_DMw_stat;
    hc_intf.write_ptr_map     ["DMw_stat"] = [=getdesign_name=]_write_ptr_DMw_stat;
    // Initialise argc/argv functions
    write_main_argc_argv_ptr = [=getdesign_name=]_write_main_argc_argv;
    argv_write_string = [=getdesign_name=]_argv_write_string;
    argv_write_ptr    = [=getdesign_name=]_argv_write_ptr;
    argv_align_ptr    = [=getdesign_name=]_argv_align_ptr;
    // Initialise storage/type-specific read/write functions map
    for (Ctp_access_fn* p = acfns; p->type_nm; p++) {
        read_signed_map [p->strg_idx][p->type_nm] = p->read_fn;
        write_signed_map[p->strg_idx][p->type_nm] = p->write_fn;
    }
    // Initialise type-specific chess_assert/chess_report functions map
    for (Chess_assert_fn* p = cafns; p->type_nm; p++) {
        chess_assert_map[p->type_nm] = p->assert_fn;
    }
    for (Chess_report_fn* p = crfns; p->type_nm; p++) {
        chess_report_map[p->type_nm] = p->report_fn;
    }
    for (Chess_return_value_fn* p = cvfns; p->type_nm; p++) {
        chess_return_value_map[p->type_nm] = p->return_value_fn;
    }
    chess_cycle_count_ptr = [=getdesign_name=]_chess_cycle_count;
    chess_exit_code_ptr = [=getdesign_name=]_chess_exit___sint;
    chess_hosted_io_ptr = [=getdesign_name=]_chess_hosted_io___Pvoid;
    // Initialise built-in type unparse map
    unparse_map["bool"] = "bool";
    unparse_map["__cchar"] = "char";
    unparse_map["__schar"] = "signed char";
    unparse_map["__uchar"] = "unsigned char";
    unparse_map["__sshort"] = "short";
    unparse_map["__ushort"] = "unsigned short";
    unparse_map["__sint"] = "int";
    unparse_map["__uint"] = "unsigned";
    unparse_map["__slong"] = "long";
    unparse_map["__ulong"] = "unsigned long";
    unparse_map["__slonglong"] = "long long";
    unparse_map["__ulonglong"] = "unsigned long long";
    unparse_map["__ffloat"] = "float";
    unparse_map["__fdouble"] = "double";
    unparse_map["__flongdouble"] = "long double";
    unparse_map["__Pvoid"] = "void *";
    unparse_map["__PPMbvoid"] = "void chess_storage(PMb) *";
    unparse_map["__PPMvoid"] = "void chess_storage(PM) *";
    unparse_map["__PDMbvoid"] = "void chess_storage(DMb) *";
    unparse_map["__PDMhvoid"] = "void chess_storage(DMh) *";
    unparse_map["__PDMwvoid"] = "void chess_storage(DMw) *";
    unparse_map["__PDMb_statvoid"] = "void chess_storage(DMb_stat) *";
    unparse_map["__PDMh_statvoid"] = "void chess_storage(DMh_stat) *";
    unparse_map["__PDMw_statvoid"] = "void chess_storage(DMw_stat) *";
    return chkapi_OK;
}

