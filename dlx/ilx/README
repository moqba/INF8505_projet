ILX


Note: this documentation can also be found as chapter 14 of the 'DLX core
processor' manual.

Introduction
============

The example core ILX demonstrates how to model interleaved multi-threaded
architectures with the IP Designer tools.

ILX is derived from example core DLX. The exercise is to hide the latency of
the instruction pipeline with 4 stages: ID-EX-ME-WB.

The register set is instantiated 4 times, allowing 4 independent threads to run
interleaved on the shared single datapath.

Cf. Chess modeling manual, section 3.7 and Go user manual, section 4.15 on
multiple register contexts â€” shadow registers.

Edits to the model
==================

*** lib/ilx.n:

> trn context_IF<ctxt>; hw_init context_IF = 0;
> properties {
>     additional_register_contexts: 3;
>     context_issue_trn: context_IF;
> }

This duplicates the register set to 4 instances and specifies the transitory on
which the PCU writes the register context to use when issuing an instruction.

*** lib/ilx.n:

If the PCU schedules the threads 4 cycles apart then the pipeline (depth=4) is
transparent for the compiler: the previous instruction has left the pipeline
when a new instruction of the same thread is issued:

  context | time
  --------|------------------------------ ...
    <0>   | IF | ID | EX | ME | WB |    | ...
    <1>   |
    <2>   |
    <3>   |
    <0>   |    |    |    |    | IF | ID | ...

In the compiler view of the model, the pipeline is collapsed (depth=1).

> #ifndef(__programmers_view__)
> #define _THREADED
> #endif
>
> #ifdef _THREADED
> enum stage_names {PF,   // Pre-fetch
>                   IF,   // Instruction Fetch
>                   ID,   // Instruction Decode,   read registers
>                   EX,   // EXecute
>                   ME,   // MEmory
>                   WB};  // Write Back registers
> #define _pipe pipe
> #else
> #define PF IF
> enum stage_names {IF, ID};
> #define EX ID
> #define ME ID
> #define WB ID
>#define _pipe trn
>#endif

So, there is a discrepancy in the model between the compiler view and the
actual hardware.

*** lib/hazards.n:

If PCU schedules the threads 4 cycles apart then there are no longer data or
control hazards. The bypass rules and the stall rules of DLX are removed.

*** lib/control.n:

The control instructions in DLX with no register input (i.e. jump, direct call)
jump in the stage ID (only 1 delay slot). The other control instructions in DLX
have register input (i.e. conditional jump, indirect call/jump/ret) and can only
jump in stage EX (2 delay slots).

As the ILX hides the pipeline, there is no hurry: in fact, there is 4 cycles
time to take the jump without penalty. All jump actions in ILX are aligned to
stage EX: uniform for PCU. The PC for a context is updated once, either an
incremental step or a certain jump in stage EX.

*** lib/ilx.n:

There a 4 threads of controls with each an own program counter. The thread
scheduler in the PCU is a basic round robin scheduler (modulo 4 increment).

The threads could run statically: 4 PC values at initialization time. Here, we
opted to enable only 1 thread at initialization time and then allow dynamic
task spawning in the other 3 threads.

> reg EN <uint4>;  // activity of threads
> hw_init EN = 1;  // first context emulates host
> properties { exclude_from_additional_register_contexts: EN; }

*** lib/ilx.n:

An interface is defined to spawn a task:

> reg host_CMD<uint1>; hw_init host_CMD = 0;
> reg host_CTX<ctxt>;
> reg host_PC <w32>;
> reg host_SP<w32>;
> properties { exclude_from_additional_register_contexts: host_SP, host_PC,
>                                                         host_CTX, host_CMD; }

In real systems, the multi-threaded core could be a slave where an external
unit submits tasks. In the closed setup of ILX, the thread 0 emulates host
functionality and submits a program <PC> with a stack frame <SP> on a
context <CTX>.

*** lib/control.n:

When the PCU notices a set host_CMD flag, the PCU inserts an instruction that
spawns the task. There is correspondence with interrupt service routines. Here,

> opn jti_instr // sets EN bit, PC and SP for given context
> opn rti_instr // clears EN bit for given context

*** lib/mutex.n:

The ILX features a 'token' register along with an atomic test_and_set
instruction. This is a provision to organize mutual exclusion: e.g. a critical
section that does not allow different threads to access shared data
concurrently.

> reg TK <uint1>;
> properties { exclude_from_additional_register_contexts: TK; }
> opn tk_test_and_set
> opn tk_clear

*** lib/ocd_if.n:

> reg ocd_ctxt<ctxt>; hw_init ocd_ctxt = 0;
> trn ocd_pc_valid<uint1>;
> trn ocd_pc_value<w32>;
> trn ocd_pc_context<ctxt>;
> properties {
>     ...
>     ocd_context_register : ocd_ctxt;
>     ocd_pc_value         : ocd_pc_value;
>     ocd_pc_context       : ocd_pc_context;
>     ocd_pc_valid         : ocd_pc_valid;
>     exclude_from_additional_register_contexts: ocd_instr, ocd_addr,
                                                 ocd_data, ocd_ctxt;

In debug mode, the active context is not taken from the thread scheduler but
instead is taken from the ocd_ctxt register. The ocd_pc_* transitories are
wired to the debug controller. There, the ocd_pc_value is compared with the set
breakpoints (when ocd_pc_valid is high). In case of a break event, the break
context is read from ocd_pc_context. This context is stored and retreivable
from the debug client.


Edits to the compiler header file
=================================

*** lib/ilx_host.h

int  get_enabl()    // read EN vector to check on activity
bool get_cmd_flag() // read host_CMD is zero before new submit
void set_flow(int ctx, int pc, int sp) // sets the 3 values and then sets cmd flag

*** lib/ilx_mutex.h

void mtx_acquire()
void mtx_release()


The PCU
=======

*** normal mode:

. stage PF

> ctxt next_ctxt = (reg_ctxt_IF == 3) ? 0 : (reg_ctxt_IF+1);
> addr next_pc = pcr_PF = PC.context(next_ctxt);
> en_r = EN;
> bool fetch = en_r[next_ctxt];
> if (fetch) pm_rd`1` = PM[pm_addr = next_pc]`1`;
> reg_ctxt_IF = next_ctxt;
> reg_valid_IF = fetch;

A basic round robin scheduler select a thread, looks up corresponding PC and
EN bit; and initiated a load from PM.

. stage IF

> pcr_IF = PC.context(reg_ctxt_IF);
> bool issue_ins = 0;
> ctxt issue_ctx = 0;
> if (/* debug_mode */) { ...
> } else if ((cmd_r = host_CMD) && ((ctx_r = host_CTX) == reg_ctxt_IF)) {
>     iword f_instr = pdg_encoding_jti__instr();
>     issue_instr(0,0,f_instr[31:24],f_instr[23:16],f_instr[15:8],f_instr[7:0]);
>     issue_ins = 1;
>     issue_ctx = reg_ctxt_IF;
> } else if (reg_valid_IF) {
>     iword f_instr = pm_rd;
>     issue_instr(pcr_IF,1,f_instr[31:24],f_instr[23:16],f_instr[15:8],f_instr[7:0]);
>     issue_ins = 1;
>     issue_ctx = reg_ctxt_IF;
>    }
> reg_valid_ID = issue_ins;
> context_IF   = issue_ctx;

In normal mode, the instruction loaded from PM is issued. In case there is a
host command pending for the current thread phase, the command is issuesd in
pipeline.

. stage ID

> reg_valid_EX = reg_valid_ID;

. stage EX

> if (reg_valid_EX) {
>     addr next_pc_EX = pcr = PC.context(context_id_EX);
>     pc_incremented = next_pc_EX + 4;
>     bool abs_jump = vd_jr_trgt_EX_sig || vd_jalr_trgt_EX_sig
>                                       || vd_jti_trgt_EX_sig;
>     bool r26_jump = vd_jal_of26_EX_sig || vd_j_of26_EX_sig;
>     bool r16_jump = vd_br_cnd_of16_EX_sig && cnd;
>     if      (abs_jump) next_pc_EX = trgt;
>     else if (r26_jump) next_pc_EX = next_pc_EX + of26;
>     else if (r16_jump) next_pc_EX = next_pc_EX + of16;
>     else               next_pc_EX = next_pc_EX + 4;
>     PC.context(context_id_EX) = pcw = next_pc_EX;
> }

The PC for a context is updated once: i.e. in stage E1.


*** debug mode:

. stage PF

> ctxt next_ctxt = (reg_ctxt_IF == 3) ? 0 : (reg_ctxt_IF+1);
> if (ocd_req || reg_ocd_req) next_ctxt = ocd_ctxt_r = ocd_ctxt;

When the ocd_req is high, the active context is not coming from the scheduler
but instead from the ocd_ctxt register. This is also the case for the first
cycle after the ocd_req is released, i.e. (!ocd_req && reg_ocd_req). So when
the debug controller commands a 'step' then a single instruction for the
context value in ocd_ctxt is issued.

. stage IF

> ocd_pc_valid   = reg_valid_IF;    
> ocd_pc_context = reg_ctxt_IF;
> ocd_pc_value   = pcr_IF;
> reg_ocd_req = ocd_req;
> if (ocd_req || reg_ocd_req) {
>     if (ocd_exe) {
>         iword f_instr = ocd_inst_r = ocd_instr;
>         issue_instr(0,0,f_instr[31:24],f_instr[23:16],f_instr[15:8],f_instr[7:0]);
>         issue_ctx = ocd_ctxt_r = ocd_ctxt;
>     }

The ocd_pc_* transitories are wired to the breakpointing logic of the debug
controller.


Cycle-accurate ISS and also single-cycle-single-thread ISS
==========================================================

The Go's reading of the ILX has the has the pipeline of depth 4 and has 4
contexts. The programmer's reading of the ILX has the collapsed pipeline.
There is value for an ISS in either reading:
- ilx_st: convenient for debugging single thread code separately
- ilx_ca: corresponds to eventual RTL; for debugging multi-threaded code

lib/common.h:
> #include "iss_defines.h"
> #if !defined(__programmers_view__) && !defined(_ISS_ST)
> #define _THREADED
> #endif

script make_model:
> proc=dlx
> # single-thread
> echo "#define _ISS_ST" > lib/iss_defines.h
> chessmk +P4 -m iss/${proc}_st
> # multi-threaded
> echo ""                > lib/iss_defines.h
> chessmk +P4 -m iss/${proc}_ca
> touch iss/${proc}_st

Note that lib/ilx_pcu.p has reduced controller for the 'ST' reading.


Parameter binding for a new work item
=====================================

*** SP:

The 4 threads each have an own stack. The linker configuration file reserves a
single range  only (e.g. _stack DMb 4 0x08000). The programmer needs to
allocate exclusive subranges for the 4 threads.

> lib/ilx_init.s
>     .text global 0 _main_init
>             ori r1,r0,#_sp_start_DMb  // init SP

> test.c
>     sp1 = 0x2000;
>     sp2 = 0x4000;
>     sp3 = 0x6000;

*** PC:

The task or work item spawned on a thread is a function with following
prototype. First, we re-use the compiler provision for interrupt service
routines:
- this function compiles with an 'rti' instead of an 'rts'
- chess_property 'register_context_switch_on_interrupt' prevents all saves
Second, function parameters, both input and output, must ve passed between
caller thread and callee thread through stack.
Examples protypes:
- void work() property(isr);                            // full void
- void work(auto int ctx) property(isr_with_arguments); // one input

The parameter binding can be abstracted in an inline function

> void set_flow(int ctx, int pc, int sp);
> inline void set_flow_int(
>     int ctx,
>     void (*pc)(auto int) property(isr_with_arguments),
>     void* sp,
>     int arg)
> {
>     *((volatile int*)sp-1) = arg;
>     set_flow(ctx, (int)pc, (int)sp);
> }

Cf. Chess modeling manual, figure 5.1 on stack memory layout. The argument buildi
area is sitting just below of the stack pointer.


Debug client for OCD
====================

Class 'ilc_pdc_interface' breaks up and combines record register 'SR' into
'MC', 'TK', and 'EN'. Function 'pdc::commands::reset_core' resets member
'ocd_current_context' to 0 (before -1).
Auxiliary procedures added to tests/ocd_test.tcl are:
    expext_break
    expect_break_context'
Updated testplans in tests/ are:
    test_02_reg.tcl
    test_10_breakpoints.tcl
    test_11_breakpoints.tcl


Multi-threaded examples
=======================

regression/C90_mt_basic/test.prx
regression/C91_mt_semaphore/test.prx
regression/C92_mt_qsort/test.prx


Practical
=========

// generate ASIP model, software libraries, both ISSs (_ca and _st), RTL, and debug client

script 'make_model'

// regression tests

cd regression/C90_mt_basic
make -f ../Makefile.test diff             // ISS vs. native
make -f ../Makefile.test rtldiff          // ISS vs. Verilog
make -f ../Makefile.test rtldiff HDL=vhdl // ISS vs. VHDL
make -f ../Makefile.test virgin           // clean dirs
cd ../..

// batch regression

cd regression
./domake virgin C9*                      // domake iterates over test dirs
./domake "rtldiff HDL=vhdl" C9*          // e.g. ISS vs. VHDL for C9* tests
cd ..

// coverage

cd regression
./make_cov_rep                             // instruction coverage report
./make_rtl_cov_rep                         // MIT-VLOG coverage report
./make_rtl_cov_rep vhdl                    // MTI-VHDL coverage report
cd ..
