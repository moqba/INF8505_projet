
// File generated by checkers version P-2019.03#e8423b9d9f#190424
// Copyright 2014-2021 Synopsys, Inc. All rights reserved.
// checkers -B -v -M -cilx_ia_work/LNa64/ilx_ia.ccf ilx

// Processor: ilx

#ifndef __Mdl_ilx_iapcu_user_c__
#define __Mdl_ilx_iapcu_user_c__

#include "checkers_declspec.h"
#include "checkers_enum.h"
#include "Mdl_ilx.h"

// This functions is called at the end of simulating an instruction and
// must set the program counter to the value for the next step. It has the
// following signature:
//
// inline void <processor>_user_next_pc(<processor>* mdl, unsigned next_pc,
//                                      unsigned nw,
//                                      Checkers_next_pc_type npt);
//
// 'mdl' is a pointer to the processor model. 'next_pc' is the next program
// counter value as calculated during simulation of the current
// instruction. 'nw' is the number of words of the instruction being
// executed. 'npt' is an enum indicating how the 'next_pc' value was
// calculated. Possible values are:
//
// npt_increment : 'next_pc' is the address of the next instruction on the
//     increment path.
//
// npt_jump : 'next_pc' is the target address of a (un)conditional
//     jump. For conditional jumps this can be the actual target address or
//     the address of the next instruction on the increment path.
//
// npt_loop_end : 'next_pc' is the result of the 'end-of-loop' functions
//     and can be address of the first instruction in the loop or of the
//     first instruction after the loop.
//
// npt_cntrl : 'next_pc' is the result of another controller instruction
//     (type 4 above).
//
// npt_delay_slot : 'next_pc' is the address of the next instruction in the
//     delay slots of an instruction. 'npt' is set to 'npt_delay_slot' for
//     all but the last delay-slot instruction. For this last delay-slot
//     instruction 'npt' is set according to the type of the instruction
//     having the delay slots. (e.g. to npt_jump for a jump with delay
//     slots).


inline void ilx_user_next_pc(ilx* mdl, unsigned next_pc, unsigned nw, Checkers_next_pc_type npt)
{
  /* User code here */
  int ctx = mdl->get_context();
  mdl->contexts[ctx].PC = next_pc;
  //std::cout << "next_pc[" << ctx << "]=" << next_pc << std::endl;

  ctx = (ctx<3) ? (ctx+1) : 0;
  mdl->context_IF = ctx;
#if 1 //
  mdl->context_id_ID = ctx;
  mdl->context_id_EX = ctx;
  mdl->context_id_ME = ctx;
  mdl->context_id_WB = ctx;
#endif

  if (mdl->host_CMD.value() && ctx == mdl->host_CTX.value()) {
    //std::cerr << "jti_instr(ctx=" << ctx << ")" << std::endl;
    mdl->host_CMD = 0;
    mdl->EN = mdl->EN.value() | (1 << ctx);
    mdl->contexts[ctx].SP = mdl->host_SP;
    mdl->contexts[ctx].PC = mdl->host_PC;
  } else {
    bool en = ((mdl->EN.value()) >> ctx) & 0x1;
    if (!en) mdl->stall();
  }
}

// This function has the following signature for absolute jumps:
//
// inline unsigned <processor>_<jump-name>(<processor>* mdl, unsigned next_pc);
//
// and this signature for relative jumps:
//
// inline unsigned <processor>_<jump-name>(<processor>* mdl, unsigned nextIncrAdddr,
//                                         int pc_offset);
//
// 'mdl' is a pointer to the processor model. 'next_pc' is the address
// of the instruction on the increment path. 'pc_offset' if the
// 'chess_pc_offset' value as specified in the nML.
//
// The function must return the next value of the program counter.
//
inline unsigned ilx_vd_rti_EX(ilx* mdl, unsigned next_pc)
{
  /* User code here */
  int ctx = mdl->get_context();
  //std::cerr << "rti_instr(ctx=" << ctx << ")" << std::endl;
  return 0; // done
}

#endif
