/*
-- File : pdc_commands.h
--
-- Contents : Declaration of PDC command class,
--            interfacing with jtag_socket library.
--
-- Copyright (c) 2014-2016 Synopsys, Inc. This Synopsys processor model
-- captures an ASIP Designer Design Technique. The model and all associated
-- documentation are proprietary to Synopsys, Inc. and may only be used
-- pursuant to the terms and conditions of a written license agreement with
-- Synopsys, Inc.  All other use, reproduction, modification, or distribution
-- of the Synopsys processor model or the associated  documentation is
-- strictly prohibited.
*/



#ifndef _pdc_commands_h
#define _pdc_commands_h

#include "pdc_opcodes.h"  // opcodes header, generated by the Go tool
#include "jts_ocd_cable.h"
#include "checkers_debugger.h"
#include "pdc_caches.h"

#include <map>
#include <iostream>

using std::string;
using std::cerr;

struct pdc_mem_instr {
    int ld_instr;
    int st_instr;
    bool via_inst_reg;  // default is via data_reg
    int addr_incr;

    pdc_mem_instr() {
        ld_instr = st_instr = 0;
    }

    pdc_mem_instr(int ld, int st, bool inst = false)
        : ld_instr(ld), st_instr(st), via_inst_reg(inst)
        {
            addr_incr = via_inst_reg ? 4 : 0;
        }
    bool empty() const { return (ld_instr | st_instr) == 0; }
};

class pdc_commands {
public:
    typedef Checkers_debugger::Core_status Core_status;
    typedef Checkers_debugger::Breakpoint_settings Breakpoint_settings;
    typedef Checkers_debugger::Watchpoint_settings Watchpoint_settings;

    enum {
        max_core_id = 30,
        nr_breakpoints = DBG_BP_HIT_INDX -1 - DBG_MODE_INDX,
        interleaved_contexts = DBG_CONTEXT_REG_WIDTH > 0
    };

    pdc_commands(int coreid, string server, int port);
    ~pdc_commands();

 // access of special registers :
    void get_status(Core_status*);
    unsigned get_program_counter();
    int put_program_counter(unsigned);
    static string pc_name;

 // refresh :
    void refresh()                              { flush_buffer(); }

 // start/stop/reset :
    void step(bool sync);
    void step_dis_int(bool sync);
    void resume(bool sync);
    void request(bool sync);
    void reset_core(bool sync);

 // hardware breakpoints/watchpoints :
    int watch_supported(const Watchpoint_settings* ws) const;
    void enable_hw_break(int nr, const Breakpoint_settings*);
    void enable_hw_break(const std::vector<int>&, const Watchpoint_settings*);
    void disable_hw_break(const std::vector<int>&);

 // software breakpoint info :
    enum {
        sw_break_enabled = 1,
        sw_break_decrements_pc = 0
    };
    typedef long long instr_type;
    static string pmem_name;
    instr_type sw_break_instr(bool export_, instr_type orig_instr);

 // buffered write access to storages (flush happpens on step/resume) :
    int put_register(string name, long long value);
    int put_memory_at(string name, unsigned address, long long value);
    void check_buffer_overflow();
    void flush_buffer();

 // blocked based read access of storages :
    int get_register(string name);
    int get_memory_at(string name, unsigned address);
    void send_and_receive()                     { cbl.send_and_receive(); }
    long long received_next_mem(string)         { return received_next(); }
    long long received_next_reg(string);

 // common registers loaded in single send-receive call :
    std::vector<string> common_regs();
    std::vector<string> common_vec_regs(unsigned vec_size);

 // direct read access of storages :
    int get_register(string name, long long& value) {
        if (get_register(name) == Checkers_debugger::ok) {
            send_and_receive();
            value = received_next_reg(name);
            return Checkers_debugger::ok;
        }
        return Checkers_debugger::failed;
    }
    int get_memory_at(string name, unsigned address, long long& value) {
        if (get_memory_at(name,address) == Checkers_debugger::ok) {
            send_and_receive();
            value = received_next_mem(name);
            return Checkers_debugger::ok;
        }
        return Checkers_debugger::failed;
    }

 // vectorised access to registers and memories :
    unsigned vector_size(string name) { return name == "PMb" ? 4 : 0; }
    int get_register(string name, pdc_caches::range elems);
    int get_memory_at(string name, unsigned address, pdc_caches::range elems);
    void received_next(string name, pdc_caches::range,
                       std::vector<long long>& vals);
    int put_register(string name, pdc_caches::range elems,
                     const std::vector<long long>& vals);
    int put_memory_at(string name, unsigned address, pdc_caches::range elems,
                      const std::vector<long long>& vals);

 // access to ocd_context_register (only when interleaved_contexts is true) :
     int put_context(int val);
     int get_context();
     int get_break_context();

 // verbosity :
    void verbose(int lvl) {
        verb = lvl;
        if (lvl > 1) cbl.set_verbose(lvl);
    }

private:
    void init_pdc_codes(int);

 // instruction codes: 0001iiii
    int request_instr;
    int resume_instr;
    int reset_instr;
    int step_instr;
    int stepdi_instr;
    int execute_instr;

 // breakpoint instruction codes: 001bbbii
    int bp_enable_instr[nr_breakpoints];
    int bp_export_instr[nr_breakpoints];
    int bp_disable_instr[nr_breakpoints];
    std::map<string,c_array<int,nr_breakpoints> > bp_watch_load_instr;
    std::map<string,c_array<int,nr_breakpoints> > bp_watch_store_instr;
    instr_type core_sw_break_instr;

 // load/store instruction codes: 010mmmmi
    std::map<string,pdc_mem_instr> mem_instr;

    string mem_name(const pdc_mem_instr&) const;

 // processor move instructions to access registers
    std::map<string,long long> reg_get_code;
    std::map<string,long long> reg_put_code;

    long long goto_r1_code;

    void init_reg_move_codes();

    struct {
        string name;
        unsigned addr;
    } reg_access_via_mem;

 // physical link
    jts_ocd_cable cbl;

    long long received_next();

 // current value of ocd_address_register, incremented on each st/ld :
    unsigned current_address;
    bool ocd_address_set;

    void put_address_register(unsigned a) {
        if (a != current_address || !ocd_address_set) {
            if (verb) cerr<< "PDC put address register: " << a << '\n';
            cbl.add_dwrite(ocd_cable::addr,a);
            current_address = a;
            ocd_address_set = true;
        }
    }
    void execute_ldst_instr(int ldst_instr, int incr) {
        cbl.add_iwrite(ldst_instr);
        current_address += incr;
    }

    int ocd_current_context;    // current value of ocd_context_register
    bool verb;
};

inline void pdc_commands::request(bool sync)
{
    if (verb) cerr << "PDC " << (sync ? "sync request\n" : "request\n");
    cbl.add_iwrite(sync ? DBG_SYNC_REQUEST_INSTR : request_instr);
    send_and_receive();
}

inline void pdc_commands::resume(bool sync)
{
    if (verb) cerr << "PDC " << (sync ? "sync resume\n" : "resume\n");
    cbl.add_iwrite(sync ? DBG_SYNC_RESUME_INSTR : resume_instr);
    send_and_receive();
}

inline void pdc_commands::step(bool sync)
{
    if (verb) cerr << "PDC " << (sync ? "sync step\n" : "step\n");
    cbl.add_iwrite(sync ? DBG_SYNC_STEP_INSTR : step_instr);
    send_and_receive();
}

inline void pdc_commands::step_dis_int(bool sync)
{
    if (verb) cerr << "PDC " << (sync ? "sync step_dis_int\n":"step_dis_int\n");
    cbl.add_iwrite(sync ? DBG_SYNC_STEPDI_INSTR : stepdi_instr);
    send_and_receive();
}

inline void pdc_commands::reset_core(bool sync)
{
    if (verb) cerr << "PDC " << (sync ? "sync reset core\n" : "reset core\n");
    cbl.add_iwrite(sync ? DBG_SYNC_RESET_INSTR : reset_instr);
    send_and_receive();
    ocd_address_set = false;
    ocd_current_context = 0;
}

inline void pdc_commands::enable_hw_break(int nr, const Breakpoint_settings* bs)
{
    if (verb) cerr<< "PDC enable breakpoint " << nr << '\n';
    put_address_register(bs->address);
    cbl.add_iwrite(bp_enable_instr[nr]);
    if (bs->export_)
        cbl.add_iwrite(bp_export_instr[nr]);
    send_and_receive();
}

inline int pdc_commands::watch_supported(const Watchpoint_settings* ws) const
//  As there is no combined watch load_and_store instruction, 2 address
//  registers are needed to watch both loads and stores.
{
    int nr = 0;
    if (ws->on_read  && bp_watch_load_instr.count(ws->memory)) nr++;
    if (ws->on_write && bp_watch_store_instr.count(ws->memory)) nr++;
    return nr;
}

inline void pdc_commands::enable_hw_break(const std::vector<int>& nrs,
                                          const Watchpoint_settings* ws)
{
    put_address_register(ws->address);
    if (ws->on_read) {
        if (verb) cerr<< "PDC enable read watchpoint " << nrs.front() << '\n';
        cbl.add_iwrite(bp_watch_load_instr[ws->memory][nrs.front()]);
        if (ws->export_)
            cbl.add_iwrite(bp_export_instr[nrs.front()]);
    }
    if (ws->on_write) {
        if (verb) cerr<< "PDC enable write watchpoint " << nrs.back() << '\n';
        cbl.add_iwrite(bp_watch_store_instr[ws->memory][nrs.back()]);
        if (ws->export_)
            cbl.add_iwrite(bp_export_instr[nrs.back()]);
    }
    send_and_receive();
}

inline void pdc_commands::disable_hw_break(const std::vector<int>& nrs)
{
    for (unsigned i = 0; i < nrs.size(); i++) {
        if (verb) cerr<< "PDC disable breakpoint " << nrs[i] << '\n';
        cbl.add_iwrite(bp_disable_instr[nrs[i]]);
    }
    send_and_receive();
}

inline unsigned pdc_commands::get_program_counter()
{
    long long val = current_address;  // restore addr_reg
    cbl.add_dwrite_dread(ocd_cable::addr,val);
    send_and_receive();
    val = received_next();
    if (verb) cerr << "PDC read PC: " << val << '\n';
    return val;
}

inline pdc_commands::instr_type pdc_commands::sw_break_instr(bool, instr_type)
{
    return core_sw_break_instr;
}

inline long long pdc_commands::received_next()
{
    long long v = 0;
    if (cbl.get_next_data(v) != 0)
        cerr << "PDC read answer failed\n";
    return v;
}

inline long long pdc_commands::received_next_reg(string)
//  a register read is done by doing 4 consecutive byte memory loads
{
    long long v = 0;
    for (int i = 0; i < 4; i++)   // BIG endian
        v |= (unsigned long long)received_next() << ((3-i)*8);
    return v;
}

inline void pdc_commands::check_buffer_overflow()
{
    if (cbl.buffer_overflow_imminent()) send_and_receive();
}

inline void pdc_commands::flush_buffer()
{
    if (!cbl.buffer_is_empty()) send_and_receive();
}

inline int pdc_commands::put_context(int val)
{
    if (interleaved_contexts && val != ocd_current_context && val >= 0) {
        ocd_current_context = val;
        cbl.add_dwrite(ocd_cable::ctxt,val);
        if (verb) cerr << "PDC put context: " << val << '\n';
    }
    return Checkers_debugger::ok;
}

inline int pdc_commands::get_context()
{
    return ocd_current_context;
}

inline int pdc_commands::get_break_context()
{
    if (interleaved_contexts) {
        if (ocd_current_context < 0) {
            cerr << "Warning: initializing ocd context to zero\n";
            ocd_current_context = 0;
        }
        long long val = ocd_current_context;  // restore ocd_context_register
        cbl.add_dwrite_dread(ocd_cable::ctxt,val);
        send_and_receive();
        val = received_next();
        if (verb) cerr << "PDC read break context: " << val << '\n';
        return (int)val;
    }
    return -1;
}


#endif
